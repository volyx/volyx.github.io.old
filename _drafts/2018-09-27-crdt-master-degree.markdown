---
layout:     post
title:      CRDT master degree
date:       2018-09-27
categories: crdt
---

\\[ n^2 = (2k + 1)^2 = \\]
\\[4k^2 + 4k + 1 = \\]
\\[ 2(2k^2 + 2k) + 1 \\]


Федеральное государственное автономное образовательное учреждение

Московский физико-технический институт (государственный университет)

Кафедра дискретной математики

Направление подготовки: 01.04.02 Прикладная математика и информатика

Магистерская программа: Современная комбинаторика 

**Исследование характеристик производительности и масштабируемости алгоритмов группового редактирования текста на основе OT и CRDT**

магистерская диссертация

Обучающийся: Волыхин Дмитрий Алексеевич

____________________

Научный руководитель: Научный сотрудник лаборатории 

прикладных исследований МФТИ-Сбербанк, 

Иванов Алексей Михайлович

____________________

г. Москва

[[TOC]]

# Введение

Теория группового редактирования текста впервые была сформулирована 29 лет назад, но сейчас стала особенно актуальна из-за роста количества устройств на одного человека и развития совместно используемых программ и документов в вебе.

Редактирование документа сегодня может быть растянуто во времени,  производиться с разных устройств или разными пользователями в совместном доступе. Если пользователь создает документ на рабочем компьютере, продолжает редактировать на телефоне, а затем на домашнем ноутбуке, то хочется, чтобы  переход между устройствами был незаметен, создавалось ощущение, что редактируешь текст с одного устройства.

Если один и тот же документ редактируют два пользователя, то хочется  чтобы текст синхронизировался как можно быстрее и оба пользователя сразу видели актуальную версию. Как быть если один из пользователей продолжил редактировать текст оффлайн? Как потом синхронизировать версии текста без конфликтов? И как быть, если пользователей будет не два, а десять или тысяча?

## Задача

Для того чтобы сравнить существующие подходы поставлены следующие цели:

* определить области применения алгоритма 

* проанализировать техники, которые применяются в этих алгоритмах

Параметры сравнения:

* Количество метаданных
* Доказана ли корректность алгоритма
	* Работает ли с символами, со строками, с гипертекстом
	* Поддерживает ли откат операций
	* Сложность операций
	* локальная вставка
	* удаленная вставка

# История развития алгоритмов группового редактирования

Проблемы группового редактирования сформулированы в первых алгоритмах операционального преобразования такие сходимость, каузальное предшествование и сохранение намерения. Первый алгоритм dOPT заложил модель для всех последующих алгоритмов, но имел проблемы со сходимостью - dOPT Puzzle. Последующие алгоритмы  Jupiter, Adopted, GOT решали проблемы алгоритма dOPT либо внося дополнительную сложность в алгоритм, либо не поддерживали откат операций Undo/Redo. Алгоритмы SOCK3, SOCK4, MOT1, MOT2 добавили синхронизацию между репликами в распределенное редактирование, что негативно отражается на добавление новых реплик в систему. Изначально модель была нацелена на работу с отдельными символами, что не подходило для практической реализации редактора. treeOPT добавляет возможно редактировать древовидные документы. Позже стало понятно, что модель заданная в dOPT на практике не подходит. В попытках найти удобную модель, но в рамках все того же семейства OT алгоритмов была предложена модель алгоритма COT, в которой на первое место ставится контекст операции, а не операция как во всех предыдущих алгоритмах. Но основным минусом всех OT алгоритмов так и осталась теоретическая сложность в доказательстве корректности и практическая сложность реализации.

Алгоритм WOOT стал первопроходцем семейства алгоритмов CRDT, где на первое место ставилась коммутативность операций. Простота с которой коммутативность решила проблемы OT положила начало новым реплицируемым структурам данных, в которых главное требование это коммутативность, ассоциативность и идемпотентность. Практическая модель стала очень похожа на хорошо известную модель частично-упорядоченных множеств и решеток. С теоретической точки зрения стало все корректно, осталось решить практические проблемы реализации: это скрывание элементов вместо удаления и эффективное хранение структуры документа.

Undo/Redo в CRDT решаются естественным образом, так как нам не важен порядок операций. Logoot решил проблему хранения графа объектов в WOOT, но обозначил новую – размер идентификаторов. TreeDoc также столкнулся с длинными идентификаторами, и с несбалансированностью редактируемых частей документа.

LogootSplit уменьшили размер идентификаторов из-за использования по строкового редактирования документа. RGA решил проблему "бесконечных идентификаторов", увеличив количество метаданных на каждый символ. 

Первые эксперименты по производительности[35] показали, что алгоритмы, основанные на CRDT, обходят OT алгоритмы по производительности в несколько раз.(Logoot обходит Sock2 в 25 раз)[35].

Работа Марка Шапиро[26]  объединила все CRDT структуры в один фреймворк, в который вошли уже известные на тот момент WOOT и Logoot алгоритмы.

В LogootTree добавили дополнительную структуры для быстрой итерации по узлам, а в RgaSplitTree добавили работу со строками и структуру идентификаторов для итерации по узлам.

# Сравнение подходов

Для решения проблем совместного взаимодействия используются два семейства фреймворков: Операциональное преобразование (Operational Transformation, OT), Commutative/Convergent Replicated Data Types (CRDT).

## Operational transformation

### Модель 

Прежде чем приступить к сравнении алгоритмов нужно разобраться с моделью. В OT алгоритмах используется следующая модель. Система группового редактирования состоит из набора состостояний  (NOTE: EQUATION), набора пользователей  (NOTE: EQUATION), набора операций  (NOTE: EQUATION). Так как нас интересует оптимистичное редактирование текста, то каждый пользователь редактирует отдельную копию данных локально.

### dOPT

Одним из первых алгоритмов для работы с групповым редактированием текста был алгоритм dOPT в системе группового редактирования GROVE(**GR**oup **O**utline **V**iewing **E**ditor)[1]

В своей работе Эллис и Гибс описали основные требования к редактору:

* высокая отзывчивость(ответ редактора должен быть максимально быстрым)

* редактор должен работать в режиме реального времени

* распределенность(все пользователи могут "подключиться" к документу и редактировать его одновременно)

* пользователи могут прекращать и возобновлять редактирование в любое время

* редактор "не знает" о намерениях пользователей

* пользователи могут редактировать одну часть документа одновременно

* пользователи подключаются к редактору по внешнему каналу

Авторы описывают две проблемы с которым сталкиваются при разработке совместных систем редактирования:

* Расходимость(Divergence)

* Нарушение каузальности(предшествования, Causalty-violation problem)

Чтобы добиться отзывчивости и устойчивости к падениям узлов авторы GROVE сохраняют все операции в лог, в так называемую реплику(копию) данных на каждом из сайтов в локальном хранилище браузера. Авторы определяют два свойства, которыми должна обладать система группового редактирования:

* Принцип сходимости(Convergence property, CP1) Все реплики должны находится в одном состоянии после редактирования.

* Принцип сохранения каузальности(предшествования, Causality preservation/Precedence property, CP2) Если на локальной реплике операция  (NOTE: EQUATION)произошла до операции  (NOTE: EQUATION), то и на других репликах  (NOTE: EQUATION)должна предшествовать  (NOTE: EQUATION).

Класс таких моделей называется - CC модель(Convergent and Causality preservation). 

Основная идея алгоритма такая, что независимый набор операций трансформируется всегда в одно состояние - удовлетворяет свойство сходимости. 

Отношение каузального порядка(предшествования) " (NOTE: EQUATION)" (Causal-ordering)

Даны операции  (NOTE: EQUATION)и  (NOTE: EQUATION), созданные на репликах  (NOTE: EQUATION)соответственно. Операция  (NOTE: EQUATION)тогда и только тогда когда

1. Если  (NOTE: EQUATION), то операция  (NOTE: EQUATION)произошла раньше чем  (NOTE: EQUATION)

2. Если  (NOTE: EQUATION), то если выполнение  (NOTE: EQUATION)на реплике  (NOTE: EQUATION)находится в отношении happend-before( (NOTE: EQUATION)) относительно генерации  (NOTE: EQUATION)

3. Существует операция  (NOTE: EQUATION), такая что  (NOTE: EQUATION)и  (NOTE: EQUATION)

Зависимые и независимые операции(dependent and independent operations)

Даны две любые операции  (NOTE: EQUATION)и  (NOTE: EQUATION).

1.  (NOTE: EQUATION)зависит от  (NOTE: EQUATION), если  (NOTE: EQUATION)

2.  (NOTE: EQUATION) и  (NOTE: EQUATION)независимые ( (NOTE: EQUATION)), если либо  (NOTE: EQUATION), либо  (NOTE: EQUATION)

Алгоритм состоит из двух компонент:

* вектор состояний(State Vector,  (NOTE: EQUATION)), который обеспечивает принцип сохранения каузальности(CP2)

* функция трансформации, которая обеспечивает свойство сходимости(CP1)

#### Свойство трансформации

Чтобы функция трансформации обеспечивала сходимость необоходимо, что бы она обладала свойством трансформации.

Для любых двух независимых операций,  (NOTE: EQUATION)и  (NOTE: EQUATION), предположим что  (NOTE: EQUATION)  (NOTE: EQUATION), то  (NOTE: EQUATION),

 где  (NOTE: EQUATION)означает эквивалентность операций. То есть после применения операций к одному и тому же тексту, на выходе получим одинаковый результат. (Transformation Property 1, TP1)

#### Компоненты

Вектор состояний(State Vector, SV) 

Каждая реплика поддерживает свой вектор состояний, состоящий из  (NOTE: EQUATION)компонентов, под одному на каждую реплику. Рассмотрим  (NOTE: EQUATION)на реплике  (NOTE: EQUATION)

1. Изначально,  (NOTE: EQUATION)

2. После выполнения операции, созданной на реплике  (NOTE: EQUATION),  (NOTE: EQUATION)компонент  (NOTE: EQUATION)увеличивается на 1, т. е.  (NOTE: EQUATION)

Матрица трансформаций

Матрица размера  (NOTE: EQUATION), где  (NOTE: EQUATION)- количество операций в системе группового редактирования

Очередь запросов

На каждой реплике находится очередь запросов, куда помещаются все операции, пришедшие реплик. Операции "вынимаются", когда алгоритм решает что операция готова к применению.

Лог запросов

Все примененные операции из очереди переходят в лог запросов, в котором хранятся в порядке вставки.

Алгоритм dOPT

При создании операции, ей присваивается приоритет, номер реплики, вектор состояний и в виде запроса она кладется в очередь запросов. 

Когда запрос пришел с реплики  (NOTE: EQUATION), проверяется есть ли запросы, которые еще не дошли с реплики  (NOTE: EQUATION), так называемые "запросы из будущего". Если такие есть, то запрос кладется в очередь, если нет - запрос  применяется.

Если реплика  (NOTE: EQUATION)применила запрос, который еще не выполнялся на отправляющей реплике, тогда проверяется приоритет запроса и запрос отправляется в функцию трансформации.

В статье приводится функция трансформации для двух операций - Insert, Delete.

Функция трансформации приводит к одному и тому же состоянию документа, вне зависимости от порядка поданных на вход операций. 

Минусы 

* Функция трансформации определена только для операций Insert, Delete. Хотя сам алгоритм dOPT синхронизирует любые операции

* Не решена проблема двух и более конкурирующих зависимых операций.

* Бесконечно растущий лог запросов и матрица трансформаций	

### dOPT puzzle

Несколько групп исследователей [2][3][6] отметили ситуацию, в которой алгоритм dOPT не работает. Такая ситуация называется dOPT puzzle - рисунок 1. Это происходит, тогда одна операция конкурирует сразу с несколькими операциями с других реплик. Алгоритмы Jupiter, GOT, Adopted решают эту проблему разными способами.

Jupiter - использует двухмерный граф состояний. Adopted - n-мерную матрицу состояний, где n-количество реплик. GOT - одномерную структуру данных.

![image alt text](/images/crdt-master-degree/image_0.png)

Рисунок 1[2]

### Jupiter

Алгоритм Jupiter[2], разработанный в компании Xerox отличается от dOPT тем, что хранит состояние на центральном сервере. Объекты синхронизируются с сервером, а уже с сервера отправляются на все заинтересованные клиенты. Проблема сохранения каузальности решается на сервере, то есть клиентам решать ее не нужно. Операции приходят на сервер в упорядоченном виде, потому что используется протокол с гарантией доставки и сохранения порядка. Это упрощает алгоритм dOPT. 

Авторы Jupiter описывают свойство TP1, которым должна обладать функция трансформации xform

 (NOTE: EQUATION) 

где c - сообщение с клиента, а s - сообщения на сервере.

Сообщения  (NOTE: EQUATION)и  (NOTE: EQUATION) должны обладать свойством, что если применить  (NOTE: EQUATION) к  (NOTE: EQUATION), и сервер применит  (NOTE: EQUATION)к  (NOTE: EQUATION), то клиент и сервер должны остаться с одним и тем же состоянием.

Еще одно различие - операции хранятся не в логе, а в двухмерном графе состояний, который хранит все возможные варианты трансформаций и выбирает подходящую. 

Минусы 

Растущая матрица состояний

Плюсы

Также существенный недостаток - dOPT применяет операции последовательно, то есть если какая-то операция "застряла" то алгоритм не будет применять другие операции пока не дождется данную операцию. В Jupiter на сервере хранится матрица всех состояний, что позволяет не ждать “опаздывающую” операцию и применять следующие.

### ADOPTED

Авторы алгоритма Adopted[3] также обнаружили проблему dOPT-puzzle, которая приводит к разным состояниям реплик - рисунок 2. В примере сайт один посылает операции Del[1, a], Ins[3, x], сайт 2 посылает Del[3,c], что приводит к расхождению реплик. 

![image alt text](/images/crdt-master-degree/image_1.png)

Рисунок 2[3]

Алгоритм Adopted решает dOPT puzzle, добавляя два свойства, которым должна удовлетворять L-функция трансформации:

* Принцип трансформации 1(TP1) (NOTE: EQUATION)

* Принцип трансформации 2(TP2)

Для любой операции  (NOTE: EQUATION)

				 (NOTE: EQUATION)

L-функция трансформации(L-transformation function) должна удовлетворять TP1  и TP2 свойствам.	

Принцип TP1 тоже самое из dOPT и Jupiter, а вот принцип TP2 требует, чтобы результат трансформации сходился над совершенно разными наборами операций.

L-функция определяется для каждого типа операций отдельно. Авторы приводят правила(**Transformation rules**), по которым создается L-функция для редактирования текста, для операций вставки и удаления. 	

					

Adopted применяет каждую операцию на каждой реплике последовательно, сохраняя результат выполнения.

Также авторы описывают как может выглядеть откат операции. Для отката операции генерируется операция обратная той, которую хотим "откатить" и применяем от имени виртуального пользователя.

Например, Insert[2, a] = Del[2, a]

Минусы

* Хранение матрицы переходов состояний размера  (NOTE: EQUATION), где  (NOTE: EQUATION) - количество реплик. При большой истории изменений может потребоваться больше памяти, чем при хранении лога операций.

* Возможны ситуации, что если операции с других реплик приходят с задержкой, то "накапливается" количество трансформаций, которые нужно произвести.

### Generic Operation Transformation

Наследником dOPT является подход в системе REDUCE(**Re**al Time **D**istributed **U**nconstrainted **C**ooperative **E**diting) - алгоритм GOT(Generic Operation Transformation)[4][5][6]. Кроме проблем расходимости и случайных перестановок представлена проблема нарушения интенции (Intention-violation problem). 

Система группового редактирования называется консистентной, если она удовлетворяет свойствам:
 

1. Сходимость. Один и тот же набор операций, выполненный на всех репликах приведет к одному и тому же состоянию реплик.

2. Принцип сохранения каузальности(предшествования).

3. Принцип сохранения намерения(интенции, Intention-preservation). Для любой операции  (NOTE: EQUATION)эффект от применения  (NOTE: EQUATION)на всех репликах такой же как и "намерение"  (NOTE: EQUATION). И эффект от применения  (NOTE: EQUATION)не изменяет эффект независимых операций.

Проблему сходимости решает вектор состояний, а проблему сохранения каузальности - отношение полного порядка. Функция трансформации освобождается от решения проблемы каузальности и решает проблему интенции.

Вектор состояний(State Vector, SV) 

Каждая реплика поддерживает свой вектор состояний, состоящий из  (NOTE: EQUATION)компонентов, под одному на каждую реплику. Рассмотрим  (NOTE: EQUATION)на реплике  (NOTE: EQUATION)

1. Изначально,  (NOTE: EQUATION)

2. После выполнения операции, созданной на реплике  (NOTE: EQUATION),  (NOTE: EQUATION)компонент  (NOTE: EQUATION)увеличивается на 1, т. е.  (NOTE: EQUATION)

Отношение полного порядка,  (NOTE: EQUATION)(Total-ordering)

Даны две операции  (NOTE: EQUATION)и  (NOTE: EQUATION), созданные на репликах  (NOTE: EQUATION)и  (NOTE: EQUATION), с векторами  (NOTE: EQUATION)и  (NOTE: EQUATION)

 (NOTE: EQUATION), если

1.  (NOTE: EQUATION)или

2.  (NOTE: EQUATION)и  (NOTE: EQUATION)

где  (NOTE: EQUATION)

Если  (NOTE: EQUATION), мы говорим что  (NOTE: EQUATION)тотально предшествует  (NOTE: EQUATION), или  (NOTE: EQUATION)тотально опережает  (NOTE: EQUATION). Отношение полного порядка совпадает с отношением причинного порядка. Если  (NOTE: EQUATION), то  (NOTE: EQUATION).

Намерение операции

Для операции  (NOTE: EQUATION)намерением будем называть эффект после выполнения ее на реплике, на которой она была сгенерирована.

#### Проблема нарушение намерения

Выполняя независимые операции на репликах мы получим разные результаты с точки зрения намерения. Рассмотрим пример на рисунке 3. Строку "ABCDE" редактируют одновременно 2 пользователя - пользователь 1 и пользователь 2. Пользователь 1 хотел вставить символы после “A”, а Пользователь 2 удалить символы “CD”. Если операции независимые, то на выходе можем получить два результата: “ABCDE” или “A12BCDE”. Хотя с точки зрения намерения результат должен получится один и тот же “A12BE”.

  (NOTE: INLINE_DRAWING)

Рисунок 3

Авторы REDUCE утверждают что система группового редактирования должна обладать 3 свойствами:

* Свойство сходимости (**C**onvergence)

* Свойство сохранения каузальности(**C**ausality-preservation)

* Принцип сохранения намерения(**I**ntention-preservation)

Так называемая CCI модель.

Проблему нарушения намерения авторы решают с помощью трансформаций операций.

REDUCE предлагает разделить трансформацию на два вида - трансформация с включением и трансформация с исключением и контекст для каждой трансформации.

Трансформация с включением(Inclusion Transformation, IT) - трансформирует операцию  (NOTE: EQUATION)против операции  (NOTE: EQUATION), таким образом что итоговая операция включает эффект от операции  (NOTE: EQUATION)

Трансформация с включением похожа на используемую функцию трансформации в алгоритме GROOVE, только там функция трансформации применялась в любым состояниям объектов, что оказалось источником dOPT Puzzle.

Трансформация с исключением(Exclusion Transformation, ET) - трансформирует операцию  (NOTE: EQUATION)против операции  (NOTE: EQUATION), таким образом что итоговая операция не включает эффект от операции  (NOTE: EQUATION)

Трансформация с исключением применяется к объектам, находящимся в разных состояниях.

Для того, чтобы производить трансформации необходимы два типа контекстов:

* Контекст исполнения(Execution Context, EC(O))

* Контекст определения(Definition Context, DC(O)))

Оба контекста зависят от набора операций на реплике. Для того чтобы применять трансформации нужно знать текущие контексты, наборы операций против которых выполняется трансформация.

Принцип сохранения намерения сохраняется, если  (NOTE: EQUATION).

Предыдущие алгоритмы сходятся если трансформации применяются к одному и тому состоянию. Трансформации операций от разных состояний приводят к нарушению принципа сохранения намерения(**I**ntention-preservation), как показано в статье [6]

		 	 	 		

Generic Operation Transformation Control Algorithm(GOT) предлагает решить проблему трансформаций операций от разных состояний, введя дополнительные функции.

Для того, чтобы определить текущее состояние объекта, и выбрать функцию трансформации вводится понятие контекста. 

Контекст операции  (NOTE: EQUATION)- это набор операций, который приводит реплику из исходного состояния к состоянию, к которому применяется операция  (NOTE: EQUATION). Такой контекст обозначим  (NOTE: EQUATION)

Операции  (NOTE: EQUATION),  (NOTE: EQUATION)называются контекстно-эквивалентными,  (NOTE: EQUATION) , если соответствующие их контексты равны,  (NOTE: EQUATION) (NOTE: EQUATION).  (NOTE: EQUATION)

Операция  (NOTE: EQUATION)контекстно-предшествует  (NOTE: EQUATION),  (NOTE: EQUATION), т и т т  (NOTE: EQUATION)

Для того, чтобы выключить/исключить операцию в/из контекста используются функции IT, ET, которые выполняют предварительные и пост-условия. 

Include Transformation( (NOTE: EQUATION)),  (NOTE: EQUATION)

1. Пред-условие на входные параметры:  (NOTE: EQUATION)

2. Пост-условие на выходные параметры:  (NOTE: EQUATION), где эффект это применения операции  (NOTE: EQUATION) в контексте  (NOTE: EQUATION), такой же как эффект от применения  (NOTE: EQUATION)в контексте  (NOTE: EQUATION).

Exclude Transformation( (NOTE: EQUATION))  (NOTE: EQUATION)

1. Пред-условие на входные параметры:  (NOTE: EQUATION)

2. Пост-условие на выходные параметры:  (NOTE: EQUATION), где эффект от применения  (NOTE: EQUATION) в контексте  (NOTE: EQUATION), такой же как эффект от применения операции  (NOTE: EQUATION)к контексту  (NOTE: EQUATION).

Трансформации IT, ET зависят от типа операций, и в статье описаны трансформации для операций вставки и удаления. 

В качестве лога используется буфер операций, который хранит список трансформированных операций.	

 (NOTE: EQUATION)- трансформированная форма операции   (NOTE: EQUATION)

 (NOTE: EQUATION)

Дополнительно, к предварительными и пост-условиями добавляется Требование Обратимости(Reversibility Requirement), которое заключается в следующем:

Даны две операции  (NOTE: EQUATION)и  (NOTE: EQUATION)

1. Если  (NOTE: EQUATION), то  (NOTE: EQUATION)

2. Если  (NOTE: EQUATION), то  (NOTE: EQUATION)

Сам алгоритм описан в  [5]. Основная идея алгоритма, что на каждом этапе алгоритма выполняются пре/пост условия, которые решают проблему сохранения интенции.

Требование обратимости(Reversibility Requirement) обеспечивает возможность операций отката, которые также удовлетворяют принципам сохранения интенции и сохранения каузальности. 

Плюсы

* Операции работают не с символами, а со строками.

Минусы

* В алгоритме также используется лог операций. Впервые представлена очистка устаревших операций и возможность отмены/применения отмененных операций(undo/do/redo). Следует отметить, что отмена/применение отмененных операций нельзя производить из пользовательского интерфейса, это внутренние операции.

### GOT Optimized

GOT - единственный алгоритм из Jupiter, Adopted, GOT, который решает dOPT puzzle и не накладывает ограничения в виде свойств  TP1, TP2 на функции трансформации.

Авторы алгоритма GOT Optimized(GOTO)[8] утверждают что если трансформации ET, IT будут удовлетворять TP1, TP2 свойствам, то это позволит уменьшить количество трансформаций.	

Определим функции трансформации контекстов.

 (NOTE: EQUATION)

Функция  (NOTE: EQUATION)трансформирует и меняет две операции в контексте исполнения, так что контексты остаются эквивалентны.

Функция  (NOTE: EQUATION)трансформирует список операции, и сдвигает его, так что списки операции остаются эквивалентными.

Функции трансформации удовлетворяют TP1 и TP2 свойствам и в предварительных условиях, и в пост условиях. В итоге получаем свойство сохранения намерения и сходимость за меньшее количество операций трансформаций.	 	 	

### SOCK2

(Sérialisation des Opérations Concurrentes par Transposition (in French))

Алгоритм SOCK2[9][10] имеет несколько другие обозначения в отличие от предыдущих алгоритмов.

#### Модель

Операция называется локальной если она применяется на той же реплике, на которой была сгенерирована.

Операция называется удаленной для реплики, если она была сгенерирована другой репликой.

Историей  (NOTE: EQUATION)объекта называется последовательность  (NOTE: EQUATION)из  (NOTE: EQUATION)операций, примененных к объекту в порядке выполнения.

 (NOTE: EQUATION)- состояния объекта  (NOTE: EQUATION)

 (NOTE: EQUATION): означает, что применение операции  (NOTE: EQUATION)изменило состояние объекта из  (NOTE: EQUATION)в  (NOTE: EQUATION).

 (NOTE: EQUATION): означает, что применение операций  (NOTE: EQUATION)изменяет состояние объекта из  (NOTE: EQUATION)в  (NOTE: EQUATION).

Две последовательности операций  (NOTE: EQUATION)и  (NOTE: EQUATION)называются эквивалентными ( (NOTE: EQUATION)) если начиная с одного состояния они приводят объект в одному и тому же состоянию.

			 (NOTE: EQUATION)

 (NOTE: EQUATION): обозначает операцию, которая реализует намерение  (NOTE: EQUATION)на объекте в состоянии  (NOTE: EQUATION).

 (NOTE: EQUATION): выражает намерение пользователя в виде операции  (NOTE: EQUATION), примененной к состоянию  (NOTE: EQUATION).

Например:

	 (NOTE: EQUATION)

	 (NOTE: EQUATION)

Для решения проблемы нарушения намерения алгоритм SOCK2 использует две функции:

* Перемотка вперед(Forward Transposition)

* Перемотка назад(Backward Transposition)

Перемотка вперед

Функция Transpose_fd (NOTE: EQUATION) возвращает результат операции  (NOTE: EQUATION), называющейся перемотанной вперед операцией  (NOTE: EQUATION)в отношении  (NOTE: EQUATION), такой что:

		 (NOTE: EQUATION)

Операция  (NOTE: EQUATION), сгенерированная относительно состояния объекта  (NOTE: EQUATION)"перематывается” вперед относительно всех объектов находящихся в истории объекта после  (NOTE: EQUATION)

Операции, полученные с других реплик также как в алгоритме dOPT сначала помещаются в очередь, а затем применяются в порядке, заданном в векторе состояний( (NOTE: EQUATION)).

Перемотка назад

 (NOTE: EQUATION)- последовательность двух операций.

Transpose_bk( (NOTE: EQUATION)) = (NOTE: EQUATION)

	 (NOTE: EQUATION)= Transpose_fd( (NOTE: EQUATION))

	 (NOTE: EQUATION)= Transpose_fd( (NOTE: EQUATION))

Перемотка вперед решает проблему конкурентных операций. Перемотка назад - переставляет операция в логе, так чтобы они оставались эквивалентны.

Плюсы

* История объекта выстраивается инкрементально

### SOCK3-SOCK4

Алгоритм SOCK3[11] состоит из трех основных процедур, которые реализуются на каждой реплике. 	 	 	 		

			

Local Execution - применяет операцию на текущей реплике и рассылает всем остальным репликам включая себя в виде тройки  (NOTE: EQUATION), где  (NOTE: EQUATION)- операция,  (NOTE: EQUATION)- идентификатор реплики,  (NOTE: EQUATION)- временная метка операции.

Causal Reception  - получает локальные и удаленные операции и отправляет их в порядке каузальности в процедуру Integrate, используя вектор состояний(временных меток)

Integration - применяет локальную операции и трансформирует удаленную операцию относительно текущего состояния объекта.					

#### SOCK3

Для использования глобального порядка между операциями используется секвенсор, который возвращает монотонно возрастающие числа. Аналог отношения полного порядка в GOT.

Функция Ticket реализует распределенный секвенсор. 
Локальный запрос выглядит как четверка 	 (NOTE: EQUATION),

а удаленный  (NOTE: EQUATION), где  (NOTE: EQUATION)возвращается функцией Ticket.

В функции Local Execution каждой операции присваивается таймстамп из секвенсора, а функция Sequential Reception ждет пока придут все операции с таймстампом меньше текущей операции, а затем применяет текущую.	Порядок таймстампов эквивалентен порядку каузальности.

Минусы 						

* В SOCK3 трансформации из "прошлого" необходимы для последующих трансформаций

#### SOCK4

Local Execution - выполняется, как только локальная операция сгенерирована. Сначала применяется локальная операция, затем кладется в буфер истории(HB), запрашивает таймстамп от секвенсора и отправляется в Deferred Broadcast для рассылки.

Deferred Broadcast - рассылает всем репликам операцию при условии что 

 (NOTE: EQUATION)

таймстамп операции больше текущего таймстампа на реплике на единицу. Это означает, что все операции меньшим таймстампом были доставлены.

Sequential Reception - аналогичная функция из SOCK3.

Integration - вызывается, при получении удаленной операции. Если операция локальная, то она игнорируется. Если удаленная, то локальные операции ожидающие рассылки сдвигаются на одну позицию вправо, на его место сохраняется удаленная операция. Далее операция трансформируется с помощью "перемотки вперед" с локальной операцией. А все локальные операции ждущие рассылки трансформируются “перемоткой назад”. 

 Минусы

* Доказательство корректности алгоритма нетривиально

* Для SOCK4 желательно быстрое сетевое соединение для секвенсора

Плюсы

* Если секвенсор выходит из строя локальные операции продолжают применяться. После того как секвенсор восстановится - редактирование можно продолжить

* Старые операции не нужны для трансформаций

![image alt text](/images/crdt-master-degree/image_2.png)

Рисунок 4. Свойства некоторых OT-алгоритмов[11]

### Tree-based Operation Transformation

Алгоритм treeOPT[12][13] работает с любой древовидной структурой, например XML документ. Предыдущие алгоритмы работали с линейной структурой документа, операции также работали только с плоским документом - Insert[x, 1], Delete[y, 2].

Хранение документа в виде дерева первым использовалось в алгоритме dARB[14]. Вместе с операцией передавался уникальный идентификатор операции и путь в дереве.

Но конфликтные ситуации не разрешаются автоматически, пользователь разрешает их в ручном режиме.

Все предыдущие OT алгоритмы используют для хранения уже выполненных или исходных операций один общий буфер. Когда реплика получает удаленную операцию, то она трансформирует ее используя все операции в буфере, независимо от того, какую часть документа редактирует пользователь. Возможно пользователи редактирует разные части документа в один момент и конфликтов никаких нет, но алгоритм все равно применяет трансформации к таким не конфликтующим операциям.

Хранение всех операций в одном буфере неэффективно. Сложность операции вставки в буфер каузально готовой операции  (NOTE: EQUATION)для алгоритмов GOT, SOCT2, SOCT3. Алгоритм dOPT имеет сложность  (NOTE: EQUATION), но имеет проблемы со сходимостью. Увеличивающийся по объему буфер негативно сказывается на скорости применения удаленных операций. Новое древовидное представления документа решает эту проблему.

				

treeOPT разбивает документ на 5 уровней(рисунок 5):

1. Документ

2. Параграф

3. Предложение

4. Слово

5. Символ

		![image alt text](/images/crdt-master-degree/image_3.png)

Рисунок 5[12]

Формально каждый узел  (NOTE: EQUATION)имеет структуру   (NOTE: EQUATION)где

*  (NOTE: EQUATION)уровень узла  (NOTE: EQUATION)

*  (NOTE: EQUATION)упорядоченный список узлов  (NOTE: EQUATION)

 (NOTE: EQUATION)

*  (NOTE: EQUATION)длина узла

		 (NOTE: EQUATION)

*  (NOTE: EQUATION)упорядоченный список операций, примененных на дочерних узлах

*   (NOTE: EQUATION)содержимое текущего узла, определен только для узлов - листов дерева.

Композитная операция - структура вида  (NOTE: EQUATION), где

* level - уровень

* type - тип операции Insertion/Deletion

* position вектор позиций, position[i] позиция на i уровне

* content - узел, представляющий содержимое операций

* stateVector - вектор состояний

* initiator - идентификатор реплики

Уровень может быть любым кроме 0, алгоритм не поддерживает удаление/добавление документа.

![image alt text](/images/crdt-master-degree/image_4.png)

Рисунок 6[12]

treeOPT следует принципам, описанным в GOT алгоритме. Каждый сайт генерирует композитные операции и применяет их к узлам дерева. Примененная операция записывается в history родительского узла(рисунок 6). Локальные операции сначала применяется к текущей реплике, а затем рассылаются на удаленные реплики. Удаленная операция помещается в очередь и ждет пока она станет "каузально готова" к применению. Функции трансформации стали сложнее в реализации, но эффективней чем в GOT. 

treeOPT работает со строками, а не с символами. Операции выглядят так InsertWord(3,1,2,"love"), где тип=insertion, уровень=слово, параграф 3, предложение 1, позиция в слове 2.	

Плюсы

* Работает со строками

* Поддерживает XML 

* Происходит меньше трансформаций из-за многоуровневости буфера

### CoWORD

Во всех предыдущих работах программа группового редактирования разрабатывалась с нуля и поддерживала базовые операции: вставка и удаление. Но функциональность современных редакторов гораздо обширнее чем системы разработанные с поддержкой группового редактирования. Авторы CoWORD[15] первыми перевели одно-пользовательское приложение в систему группового редактирования. Файл из программы Microsoft Word переведен на движок CoWORD.

CoWORD использует подход прозрачной трансформации(Transparent Adaptation, TA) - поступающие от приложения операции трансформируются в OT операции и рассылаются на удаленные реплики. 

Процесс применяния операций делится на три части:

* Word API Layer

* Adaptation Layer

* OT Layer

Word API Layer отвечает за адресацию объектов в модели документа Word. Документ состоит из разных объектов: текст, графика, клипарт. 

OT Layer работает с OT примитивами - операциями Insert, Delete, Update, который определены уже плоском представлении документа Word, предоставляемым Word API Layer.

Adaptation Layer приводит операция с объектами в Word API Layer в OT вид в зависимости от типа объекта и следит за возможность отката операций.

Минусы:

* Программа должна предоставлять интерфейс для возможно подключения OT алгоритма

* Все объекты программы должны быть адаптированы для трансформаций. Для каждого нового объекта, который нужно синхронизировать определяется новый набор функций трансформации.

### Operation Transformation with Synchonizer

Синхронизатор - это процесс, которой принимает на вход две различные копии объекта, и приводит их к одному состоянию.

В статье [16] представлен алгоритм синхронизатора, который удовлетворяет свойства модели группового редактирования:

* сходимость

* каузальность

* сохранения намерения

Для синхронизации используется алгоритм SOCK4, так как приводит историю операций к идентичному состоянию на всех репликах.

На вход синхронизатору подается история изменений и таймстамп реплики. В статье рассматривается алгоритм на примере синхронизации операций по работе с файловой системой.

Минусы

* Для каждого набора операций необходимо определить набор функций трансформаций, обладающих свойствами C1, C2, и доказать их корректность

### Merge based on Operational Transformation

Оба алгоритма MOT1 и MOT2[17] использует SOCK4 алгоритм для трансформаций, но добавляют синхронизатор, который умеет сливать историю двух реплик в одну. То есть если в предыдущих алгоритмах реплики обменивались операциями, то в MOT1, MOT2 реплики сходятся в одному состоянию обмениваясь историями операций(History Buffer, Log в OT алгоритмах, рисунок 7).

![image alt text](/images/crdt-master-degree/image_5.png)

Рисунок 7[17]

В статье представлено два алгоритма: 

* MOT1 централизованный алгоритм, который работает в режиме master-slave, то есть одна из реплика, объявленная "мастером" получает все обновления первой.

* MOT2 децентрализованный алгоритм

В отличие от  [16] MOT1 не использует секвенсор из SOCK4, так как операции интегрируется уже в "правильном" порядке и слияние независимых операция  вызывается, для операций, у которых порядок не важен.

При слиянии истории MOT2 использует порядок операций, с реплик генерирующих операции. В начале алгоритма определяется одинаковая общая часть истории двух реплик, а затем производится трансформация конкурирующих операций с приоритетом операциям, которые сгенерированные на данных репликах. Получаем отношение полного порядка без центрального сервера.

### Time Interval Based Operational Transformation

Алгоритм TIBOT[18] использует логические часы вместо вектора состояний. 

Логические часы начинают с 0 на каждой реплике и могут "тикать" с разной скоростью, главное чтобы эта скорость была меньше чем интервал между пользовательским вводом.

Таким образом отношение полного порядка через логические часы можно выразить так:

Дано две операции  (NOTE: EQUATION) и  (NOTE: EQUATION)сгенерированные на репликах  (NOTE: EQUATION)соответственно,

 (NOTE: EQUATION)если  (NOTE: EQUATION)или  (NOTE: EQUATION)и  (NOTE: EQUATION), или  (NOTE: EQUATION)и  (NOTE: EQUATION), где  (NOTE: EQUATION)функция получения логического времени.

TIBOT использует те же функции трансформации, что и GOTO , а также одномерный исторический буфер.

Плюсы:

* Решается dOPT пазл, используя одномерный исторический буфер

* алгоритмическая сложность алгоритма  (NOTE: EQUATION)в сравнении с  (NOTE: EQUATION)в GOTO алгоритме

* решается TP2 puzzle без использования ET трансформаций и секвенсора

					

### ANYUNDO

Алгоритм ANYUNDO[19] расширяет GOTO, добавляю возможность отката операций.

Дан пустой документ с исходным состоянием  (NOTE: EQUATION), и список операций  (NOTE: EQUATION), состояние документа  (NOTE: EQUATION)после последовательного применения операций  (NOTE: EQUATION) представляется как

		 (NOTE: EQUATION)

Обозначим откатом операции  (NOTE: EQUATION) - (NOTE: EQUATION). Когда пользователь выполняет  (NOTE: EQUATION)то ожидает, что документа перейдет в состояние, как будто операции  (NOTE: EQUATION)не было, а все остальные операции были произведены.

Эффект отката

Дано состояние документа  (NOTE: EQUATION)

Эффект от отката операции переведет состояние документа в  (NOTE: EQUATION)

		 (NOTE: EQUATION)

где  (NOTE: EQUATION),  (NOTE: EQUATION)- операция, которую система выполнит вместо операции  (NOTE: EQUATION).

Свойство отката

Дано состояние документа:

		 (NOTE: EQUATION)

откат операций между  (NOTE: EQUATION)и  (NOTE: EQUATION)включительно восстанавливает документ к состоянию:

		 (NOTE: EQUATION)

Предполагается, что каждая операция имеет обратную операцию. Для операции  (NOTE: EQUATION) обратная операция  (NOTE: EQUATION). Для Insert - обратная Delete, для Delete обратная - Insert.

Пара операций  (NOTE: EQUATION)должна обладать следующими свойствами:

1. Обратное свойство 1(Inverse property 1, IP1). Для любого состояния документа  (NOTE: EQUATION)и пары операций  (NOTE: EQUATION)имеем  (NOTE: EQUATION), что означает, что пара операций  (NOTE: EQUATION)эквивалентна одной операции идентификации  (NOTE: EQUATION)относительно эффекта состояния документа.

2. Обратное свойство 2(Inverse property 2, IP2). Для любой операции  (NOTE: EQUATION)и пары операций  (NOTE: EQUATION) имеем:  (NOTE: EQUATION), что означает, что пара операций  (NOTE: EQUATION) эквивалентна одной операции идентификации относительно эффекта трансформации.

Вместе со свойством IP3, данных трех свойств достаточно для консистентной модели редактирования с откатом.

3. Обратное свойство 3(Inverse property 3, IP3). Даны две операции   (NOTE: EQUATION)и  (NOTE: EQUATION), если  (NOTE: EQUATION), и  (NOTE: EQUATION), то  (NOTE: EQUATION).

Алгоритм ANYUNDO называется так, потому что может откатывать любые операции в любом порядке. Алгоритм использует те же функции трансформации IT, ET, что и алгоритм GOTO и использует тот же буфер истории HB.		

Есть несколько ситуаций, когда алгоритм приводит модель в не консистентное состояние.

1. IP2-Violation Puzzle

2. IP3-Violation Puzzle

Проблемы решены в алгоритме ANYUNDO-X				

### Context-based Operational Transformation

Модель предыдущих алгоритмов основывается на операциях. Возникшие в процессе dOPT puzzle и TP2 puzzle решаются с помощью усложнения алгоритма. Откат операций не был предусмотрен изначально, поэтому реализация поверх готовых алгоритмов так сложна. Авторы COT[20] представляют новую модель для группового редактирования, основанную на понятии операционного контекста. 

Каждая операция  (NOTE: EQUATION)связана с контекстом  (NOTE: EQUATION), который определяется состоянием объекта на котором применяется операция. Контекст предназначен для:

1. операция применяется только если контекст операции и состояние документа эквиваленты

2. операция трансформируется с включением(IT) только если контексты двух операций одинаковые

Представление состояния документа(Document state representation, DS)

Состояние документа представляется следующим образом:

1. Исходное состояние  (NOTE: EQUATION)

2. После применения операции  (NOTE: EQUATION)на  (NOTE: EQUATION)получаем новое состояние документа  (NOTE: EQUATION)

В  (NOTE: EQUATION)используется исходные операции, а не трансформированные, это необходимо для определения отката операций.

Формально контекст операций

1. Для исходной операции  (NOTE: EQUATION), где  (NOTE: EQUATION)состояние документа, на котором была сгенерирована операция  (NOTE: EQUATION).

2. Для обратной операции(операции отката)  (NOTE: EQUATION),  (NOTE: EQUATION), где  (NOTE: EQUATION)- операция которую необходимо откатить

3. Для трансформированной операции  (NOTE: EQUATION), где  (NOTE: EQUATION)

Отношение контекстной зависимости  (NOTE: EQUATION) (NOTE: EQUATION)

Вектор контекста - представляет список операций контекста. Операция уникально идентифицируется структурой  (NOTE: EQUATION), где  (NOTE: EQUATION)- идентификатор реплики, ns - локальный последовательный номер операции. Операции отката выглядят так: 

 (NOTE: EQUATION)где  (NOTE: EQUATION) номер группы отката.

Вектор контекста представляет N-мерный вектор, состоящий из операций и операций отката.

Для операции  (NOTE: EQUATION)с контекстом  (NOTE: EQUATION) контекст вектор  (NOTE: EQUATION)определен так:

	 (NOTE: EQUATION)где  (NOTE: EQUATION),

1.  (NOTE: EQUATION)- все исходные операции сгенерированные на реплике  (NOTE: EQUATION)

2.  (NOTE: EQUATION)представляет все операции отката, для операций сгенерированных на реплике  (NOTE: EQUATION), где  (NOTE: EQUATION), представляет группы отката с  (NOTE: EQUATION)относящейся с к операции с номером  (NOTE: EQUATION). 

Например на рисунке 8 состояние документа будет таким  (NOTE: EQUATION)Вектор контекста соответственно  (NOTE: EQUATION)

![image alt text](/images/crdt-master-degree/image_6.png)

Рисунок 8[20]

### SDT

Авторы SDT[21] рассматривает две проблемы групповых редакторов:

* расходимость

* нарушение связи от эффектов операций(operation effects relation violation, ERV)

Представлена новая модель консистентности CSM:

* каузальность(**c**ausality)

* сохранение эффекта одной операции(single-operation effects)

* сохранение связи от эффекта нескольких операций(multi-operation effects)	 	 		

Проблема ERV показана на рисунке 9. Реплики 2,3 расходятся - на реплике 2 получаем строку "a21c", на реплике 3 строку “a12c”.

 ![image alt text](/images/crdt-master-degree/image_7.png)	

Рисунок 9[20]			

Проблема происходит из-за того, что после трансформаций не учитывается связь между эффектами операций. 

				

Плюсы:

* новая модель консистентности CSM

* решают ERV puzzle

* формально доказано решения TP2 puzzle

### Landmark-based transformation

Модель

Символ-ориентир. Для любых трех символов  (NOTE: EQUATION),  (NOTE: EQUATION)называется символом ориентиром между  (NOTE: EQUATION)и  (NOTE: EQUATION)если  (NOTE: EQUATION)или  (NOTE: EQUATION).

Отношение полного порядка между символами и символом ориентиром получается из аргументов операций подаваемых на вход функциям трансформации.

Авторы алгоритма LDT[22] улучшают алгоритм SDT по алгоритмической сложности функции интеграции удаленных операции с  (NOTE: EQUATION)до  (NOTE: EQUATION) в худшем случае, дают более просто условия на функции трансформации. Выполнение данных условий на IT/ET функции убирает необходимость в отдельном доказательстве корректности алгоритма.

### Wave

Google Wave[23,24,25] - самый известный из групповых редакторов. Сейчас на его основе построен Google Docs - система группового редактирования. 

Модель

Каждый вейв клиент обменивается сообщениями - вейвами(волнами, wave). Каждый из которых содержит набор вейвлетов(всплесков, wavelets). Вейвлет состоит из набора документов. Документ представляет собой сообщения с метаданными в виде диалога. Документы имеют вид XML документа с аннотациями - дополнительными данными в формате ключ-значение, которые можно дописать к любому участку документа. В вейв документе аннотации используются например для форматирования текста. Аннотации могут пересекаться.

Вейв клиент взаимодействует с вейв сервером через набор операций

* insertCharacters — вставка строки по индексу

* deleteCharacters —удаление строки по индексу

* openElement — создать открывающий XML тэг по индексу

* deleteOpenElement — удалить открывающий XML тэг по индексу

* closeElement — закрыть первый открытый тэг по индексу

* deleteCloseElement — удалить закрывающий тэг по индексу

* annotationBoundary — добавить аннотацию 

* retain — увеличить индекс на указанное значение

Wave умеет композировать операции - сливать несколько операций в одну. Композиция операций применяется только к некоторым операциям, и является некоммутативной - важен порядок сливания операции.

Wave сервер работает по модели Jupiter - все операции отправляются на сервер, а затем каузально синхронизированные и трансформированные отправляются на реплики.

## Convergent and Commutative Replicated Data Types

В статье [26] предложена концепция CRDT, в которой описаны два типа CRDT:

* Convergent Replicated Data Types, CvRDT - реплицируемые структуры данных на основе слияния состояний

* Commutative Replicated Data Types, CmRDT - реплицируемые структуры данных на основе сходимости операций

В работе представлен фреймворк, объединяющий несколько структур данных:

* G-Counter(Increment Only Counter)

* PN-Counter(Increment, Decrement Counter)

* LWW-Register(Last-Write-Wins Register)

* MV-Register(Multi-Value Register)

* G-Set(Grow Only Set)

* 2P-Set(Two-Phase-Set)

* OR-Set(Observed-Removed Set)

* Add-only monotonic DAG

* RGA

* TreeDoc

CvRDT структуры, их еще называют state-based(основаны на обмене состояний) обмениваются между репликами состояниями объекта. Основную функцию в таких структурах выполняет функция merge, которая определяет как слить два состояния в одно. Спецификаци state-based приведена на рисунке 10:

![image alt text](/images/crdt-master-degree/image_8.png)

Рисунок 10[26]

CmRDT структуры или op-based(основанные на обмене операциями) обмениваются между репликами операциями. В спецификации алгоритм применения локальных и удаленных операций вынесен в отдельные функции, но они могут вызывать одну и туже функцию применения операций(рисунок 11).

![image alt text](/images/crdt-master-degree/image_9.png)

Рисунок 11[26]

Также в статье показано как один подход можно вывести из второго и наоборот. Позже стало понятно, что структуры данных для редактирования текста используемые в WOOT, Loogot являются CRDT структурами. Рассмотрим известные CRDT алгоритмы для группового редактирования текста.

### WithOut Operational Transformation, WOOT

Модель WOOT[26]

Рассматривается сеть из нескольких узлов. Для того, чтобы изменить данные на узле, узел генерирует операции, которые:

1. выполняются немедленно на узле

2. рассылаются всем узлам в сети

3. принимаются и интегрируются на каждом узле 

WOOT использует следующую нотацию для операций:

*  (NOTE: EQUATION)вставляет элемент  (NOTE: EQUATION)между элементами  (NOTE: EQUATION)и  (NOTE: EQUATION)

*  (NOTE: EQUATION)удаляет элемент  (NOTE: EQUATION)

Такой набор операций выбран вместо привычных Insert[p,e], Delete(p).

Так как функции вставки, удаления зависят от элемента, то элемент должен обладать уникальным идентификатором в строке(рисунок 12).

![image alt text](/images/crdt-master-degree/image_10.png)

Рисунок 12[26]

Для достижения свойства сходимости WOOT использует отношение полного порядка, которое определяется через монотонную функцию - сравнение символов например.

Пример, на узел приходит операция  (NOTE: EQUATION), а между  (NOTE: EQUATION)уже находятся символы ‘3’ и ‘1’. Не ясно, в какую из возможных позиций вставить символ из операции.

Эту проблему решает линейная монотонная функция. В итоге получаем одинаковые реплики независимо от порядка получения операций - то есть свойство сходимости.(CP1)

WOOT использует другое определение каузальности операций - семантическое. В dOPT, GOTO отношение каузальности предполагало важность применения операций именно в том порядке, в котором операции были сгенерированы на реплике. Рассмотрим пример. Реплика сгенерировала последовательно операции  (NOTE: EQUATION) (NOTE: EQUATION). У данных операций нет отношения каузальности, так как все равно в каком порядке применять их на реплике. Но по из-за использования Лэмпортовского определении каузальности, порядок применения операций будет сохранятся на каждой реплике. WOOT использует семантическую каузальность. Семантически каузальные операции не могут быть выполнены в произвольном порядке, так как зависят от результата работы предшествующей операции. Например:  (NOTE: EQUATION)С точки зрения WOOT операции  (NOTE: EQUATION)независимые, а операции  (NOTE: EQUATION)- зависимые.

WOOT управляет W-символами, которые инкапсулируют дополнительную информацию о символе: идентификатор, видимость и порядок.

W-символ c - пятерка значений  (NOTE: EQUATION)где

* id - идентификатор символа

*  (NOTE: EQUATION)- алфавитное значение символа

*  (NOTE: EQUATION)определяет видимый символ или скрытый

*  (NOTE: EQUATION)- идентификатор предыдущего W-символа

*  (NOTE: EQUATION)- идентификатор следующего символа

Предыдущий W-символ для  (NOTE: EQUATION) обозначается как  (NOTE: EQUATION), следующий W-символ за c обозначается как  (NOTE: EQUATION).

Каждая реплика s имеет уникальный идентификатор  (NOTE: EQUATION), логические часы  (NOTE: EQUATION), последовательность W-символом  (NOTE: EQUATION), и пул ожидающих операций  (NOTE: EQUATION)Идентификатор реплики и логические часы используются для уникальной идентификации символов.

Идентификатором символа является пара  (NOTE: EQUATION)где  (NOTE: EQUATION)- идентификатор реплики и  (NOTE: EQUATION)- число. Когда W-символ генерируется на реплике  (NOTE: EQUATION), его идентификатор устанавливается в  (NOTE: EQUATION).

Для каждой новой операции на реплике  (NOTE: EQUATION), логические часы  (NOTE: EQUATION)инскрементируются. Так как  (NOTE: EQUATION)уникальное значение, то эта пара - уникальный идентификатор для символа.

W-строка - упорядоченная последовательность W-символов  (NOTE: EQUATION)где  (NOTE: EQUATION)и  (NOTE: EQUATION)специальные W-символы, которые отмечают начало и конец последовательности.

Для W-строки S определены следующие функции

*  (NOTE: EQUATION)обозначает длину  (NOTE: EQUATION)

*  (NOTE: EQUATION)обозначает элемент на позиции  (NOTE: EQUATION)в  (NOTE: EQUATION). Первый элемент в W-строке начинается с 0, последний с  (NOTE: EQUATION)

*  (NOTE: EQUATION)возвращает позицию элемента  (NOTE: EQUATION)в  (NOTE: EQUATION)

*  (NOTE: EQUATION)вставляет элемент  (NOTE: EQUATION)в  (NOTE: EQUATION)на позицию  (NOTE: EQUATION)

*  (NOTE: EQUATION)возвращает часть строки  (NOTE: EQUATION)между элементами  (NOTE: EQUATION)и  (NOTE: EQUATION)

*  (NOTE: EQUATION)возвращает  (NOTE: EQUATION), если  (NOTE: EQUATION)содержит  (NOTE: EQUATION)

Следующие функции используются для связи W-строки и текстовой строки

*  (NOTE: EQUATION)представления  (NOTE: EQUATION)в текстовом формате

*  (NOTE: EQUATION) (NOTE: EQUATION)i-тый видимый символ из  (NOTE: EQUATION)

#### Алгоритм

Генерация 

Каждая операция разделена по типу Insert/Delete. Функция  (NOTE: EQUATION)возвращает W-символ операции.

Когда пользователь взаимодействует с редактором, он видит только текстовое представление строки -  (NOTE: EQUATION)(Рисунок 13)

![image alt text](/images/crdt-master-degree/image_11.png)

![image alt text](/images/crdt-master-degree/image_12.png)

Рисунок 13[26]

Прием

Пришедшая операция сразу добавляется в пул, откуда достается затем в отдельном процессе "по готовности"(Рисунок 14).

![image alt text](/images/crdt-master-degree/image_13.png)![image alt text](/images/crdt-master-degree/image_14.png)![image alt text](/images/crdt-master-degree/image_15.png)![image alt text](/images/crdt-master-degree/image_16.png)

Рисунок 14[26]

Интеграция

Для интеграции операции удаления, находится символ и выставляется флаг видимости в False.

Для интеграции операции вставки необходимо найти местоположение "соседей" символа(Рисунок 15).

![image alt text](/images/crdt-master-degree/image_17.png)

Рисунок 15[26]

Плюсы

* Не имеет центрального сервера

* Не использует векторные часы для определения каузальности

* Используются короткие идентификаторы символов

Минусы

* Удаленные символы остаются в строке. Возможно решить установкой времени "протухания" и сборкой мусора.

* Количество мусора может превышать количество полезной информации

### TreeDoc

#### Модель

Первым алгоритмом для редактирования текста из семейства CRDT был алгоритм TreeDoc[28].

Документ реплицирован на несколько реплик. Локальная операции к применяются сразу же документу и добавляются лог. Операции из лога отправляются на другие реплики. В конечном счете все реплики должны получить все операции, не обязательно в одинаковом порядке.

Документ состоит из линейной последовательности атомов. Атомом может быть символ, либо любая другая неизменяемая структура. Над документом можно производить две операции:

* insert(insertpos, newatom, S) вставляет атом в документ. Позиции предыдущих атомов в документе строго меньше insertpos нового атома. S - реплика, на которой сгенерирована операция.

* delete(delpos, S) визуально удаляет атом на позиции delpos. Атом может находится в документе после удаления, но быть скрыт.  S - реплика, на которой сгенерирована операция.

Документ хранится в виде бинарного дерева. Каждый узел хранит атом либо nil. Идентификатор атом - путь к его узлу в дереве. Ребро к левому узлу - 0, ребро к правому узлу - 1. Пример: на рисунке документ "abcdef", идентификатор id(a)=[00], id(b)=[0], id(c)=[], id(d)=[10], id(e)=[1], id(f)=[11]. Между идентификаторами существует отношение частичного порядка(Рисунок 16).

![image alt text](/images/crdt-master-degree/image_18.png)

Рисунок 16[28]

#### Алгоритм

Удаление атом реализуется просто - находится удаляемый узел и его содержимое устанавливается как nil. Если удаляемый узел - лист, то можно удалить узел безвозвратно. Алгоритм поддерживает сборку мусора для "точно удаленных" узлов.

Вставка нового узла в дерево поддерживает балансировку дерева. Новый узел обладает уникальным идентификатором. Например после вставки символа "X" между “c” и “d” получим следующей дерево. id(X)=[100] Рисунок 17.

![image alt text](/images/crdt-master-degree/image_19.png) 

Рисунок 17[28]

Для поддержки вставки независимых операций каждый узел содержит идентификатор реплики, и дерево может содержать несколько узлов при конкурентных вставках(Рисунок 18).

![image alt text](/images/crdt-master-degree/image_20.png)

Рисунок 18[28]

Полная версия алгоритма имеет несколько оптимизаций как например приведение дерева к плоскому буферу. Также предлагается структура данных Mixed Tree, которая использует двухфазный коммит для удаления устаревших узлов.

Плюсы

* Вместо атомов можно использовать любый неизменяемые структуры

Минусы

* Дерево несбалансированно. Так как больше всего редактирований происходит в одной части дерева,

* Необходим сборщик мусора

### Logoot

#### Модель

В Logoot[29] документ состоит из строк, которые определены как  (NOTE: EQUATION)где content - текстовая строка, а pid - уникальный идентификатор позиции. Изначально в документе существует две виртуальных строки  (NOTE: EQUATION)и  (NOTE: EQUATION)который обозначают начало и конец документа.

Основная идея - вставлять строки и генерировать новую позицию  (NOTE: EQUATION)такую что  (NOTE: EQUATION)где  (NOTE: EQUATION)- позиция предыдущей строки, а  (NOTE: EQUATION)позиция следующей строки(Рисунок 19).

![image alt text](/images/crdt-master-degree/image_21.png)

Рисунок 19[29]

Чтобы операция были коммутативными, идентификаторы позиций должны быть уникальными. Пользователь может вставить строку в любое время, поэтому мы должны генерировать идентификатор позиции  (NOTE: EQUATION)такой что  (NOTE: EQUATION)для любых  (NOTE: EQUATION)и  (NOTE: EQUATION).

Каждая реплика поддерживает персистентные логические часы  (NOTE: EQUATION), значение которых инкрементируется при создании новой строки.

Идентификатор это пара  (NOTE: EQUATION), где  (NOTE: EQUATION)- целое число,  (NOTE: EQUATION)- идентификатор реплики.

* Позиция это список идентификаторов

* Идентификатор позиции генерируется репликой как пара  (NOTE: EQUATION)где  (NOTE: EQUATION)- позиция, а  (NOTE: EQUATION)значение часов  (NOTE: EQUATION)

Отношение полного порядка между идентификаторами устанавливается следующим образом

* Пусть  (NOTE: EQUATION)и  (NOTE: EQUATION)две позиции.  (NOTE: EQUATION)тогда и только тогда (NOTE: EQUATION)

* Пусть  (NOTE: EQUATION)- два идентификатора.  (NOTE: EQUATION)тогда и только тогда когда  (NOTE: EQUATION)или  (NOTE: EQUATION)и  (NOTE: EQUATION)

Мы только сравниваем позиции, а не логические часы так как не может быть двух строк с одинаковой позицией.

Пример документа в модели Logoot, рисунок 20.

![image alt text](/images/crdt-master-degree/image_22.png)

Рисунок 20[29]

#### Редактирование документа

	При редактировании документа в Logoot это не одна операция, а несколько, поэтому нужно генерировать сразу несколько идентификаторов позиций. Для этого в определена функций generateLinePosition(p,q,N,s), которая генерирует N позиций между позицией p и q. Для получения позиций наименьшей длины сначала определяется наименьший по длине префикс у позиций p и q(Рисунок 21).

![image alt text](/images/crdt-master-degree/image_23.png)

Рисунок 21[29]

Функция prefix(p, i) возвращает число, меньшее чем  (NOTE: EQUATION), в котором каждая цифра это  (NOTE: EQUATION), цифры первых  (NOTE: EQUATION)идентификаторов от  (NOTE: EQUATION)(заполненных 0 если  (NOTE: EQUATION)). Функция  (NOTE: EQUATION)создает позицию  (NOTE: EQUATION)где  (NOTE: EQUATION)это  (NOTE: EQUATION)цифр от  (NOTE: EQUATION). Для определения  (NOTE: EQUATION)используются следующие правила:

1. если  (NOTE: EQUATION)то  (NOTE: EQUATION)

2. если  (NOTE: EQUATION)то  (NOTE: EQUATION)

3. если  (NOTE: EQUATION)то  (NOTE: EQUATION)

4. либо  (NOTE: EQUATION)

Например, на реплике  (NOTE: EQUATION)необходимо вставить строку между  (NOTE: EQUATION),  (NOTE: EQUATION)можно взять позицию из любого из данных множеств:

*  (NOTE: EQUATION)

*  (NOTE: EQUATION)

	 (NOTE: EQUATION)

	 (NOTE: EQUATION)

 Можно выбрать любое значение из данных множеств, но для того чтобы генерировать различные идентификаторы на разных репликах применяется рандомизированная функция.

Плюсы

* Работает со строками

* Неограниченное количество пользователей

* Без меток сокрытия(tombstone)

* Переиспользуемые идентификаторы после удаления

Минусы

* Идентификаторы неограниченной длины

### RGA

Авторы статьи[30] предлагают концепцию реплицированных абстрактных структур данных(Replicated Abstract Data Type, RADT)[30] и предлагают реализацию трех структур данных, которые модифицируются оптимистично:

* Реплицированный массив фиксированного размера(replicated fixed-size array, RFA)

* Реплицированная хеш таблица(replicated hash table, RFA)

* Реплицированный массив(replicated growable array, RGA)

Для нас интересен в первую очередь RGA, так как на его основе можно строить систему группового редактирования.

#### Модель

Для того чтобы абстрактные структуры данных сходились к одному и тому состоянию на репликах необходимо выполнение двух свойств:

* Коммутативность операций(operation commutativity, OC) Все операции должны быть коммутативны.

* Транзитивность предшествования (precedence transitivity, TP) Правила предшествования должны быть транзитивны. Правила предшествования необходимы для разрешения конфликтных намерений. Удаленные операции проектируются с учетом правил предшествования.

#### RADT

Реплицированная абстрактная структура данных - расширенная форма абстрактной структуры данных. Модель RADT определена следующим образом:

* RADT содержит конечный набор типов операций (OPTYPE)

* Копии RADT содержатся на каждой из реплик

* Локальная операция применяется сначала на той реплики, на которой сгенерированная, затем отправляется на другие реплики и применяется как удаленная операция.

* Локальная операция применяется сразу, используя алгоритм для применения локальной операции

* Удаленная операция применяется, когда она становится "каузально готова", используя алгоритм применения удаленной операции

RGA поддерживает операции: Insert, Delete, Update, Read, каждая из который имеет индекс в качестве параметра. 

Алгоритм для локальных операций - рисунок 22.

![image alt text](/images/crdt-master-degree/image_24.png)

Рисунок 22[30]

S4Vector

S4Vector(int ssn, int sid, int sum, int seq) где 

* ssn глобальный номер сессии, который растет монотонно

* sid это идентификатор реплики

* sum - сумма значений векторных часов

* seq зарезервирован для меток удаления(tombstone)

Например, для векторных часов [1,2,3], на реплике 0, с сессией 4, S4Vector=[4,0,6,1]

S4Vector уникален для каждой операции, так как значение sum уникально для каждой операции.

Даны два S4Vector’a  (NOTE: EQUATION)и  (NOTE: EQUATION).  (NOTE: EQUATION)тогда и только тогда, когда 

1.  (NOTE: EQUATION)

2.  (NOTE: EQUATION)

3.  (NOTE: EQUATION)

Локальной операции присваивается  s4vector перед рассылкой на удаленные реплики. В хеш таблице хранится пара ключ-значение, где ключ s4vector, глобально уникальный, значение - узел содержащий символ. RGA хранит состояние документа в связном списке.

Узел в RGA это структура из 5 переменных:

*  (NOTE: EQUATION)s4vector уникальный идентификатор узла. Для упорядочивания операций вставки.

*  (NOTE: EQUATION)s4vector для операций обновления, удаления.

* два указателя на предыдущий и следующий узел

* head - указатель на начало связанного списка

Алгоритм вставки состоит из 4 этапов(рисунок 23)

* Находим левый  (NOTE: EQUATION)в хеш таблице используя s4vector. Левый coobject всегда существует так как узлы не удаляются из связного списка, а скрываются.

* Создаем новый узел с s4vector и помешаем в хеш таблицу

* Из-за конкурентных операций, мы не можем вставить узел сразу в связный список. А должны пройтись по узлам и найти первый предшествующий узел с s4vector.

* Связываем новый узел с первым "предшествующим" узлом

![image alt text](/images/crdt-master-degree/image_25.png)

Рисунок 23[30]

Алгоритмы удаления, обновления работают похожим образом при поиске узла, только при удалении узел помечается как удаленный, а при обновлении - обновляется значение узла. 

Плюсы

*  (NOTE: EQUATION)сложность на вставку, в отличие от  (NOTE: EQUATION)в OT алгоритмах. Рисунок 24

Минусы

* Удаленные узлы не удаляются, а помечаются как удаленные

* Алгоритм сборки удаленных узлов должен синхронно убирать узлы сразу со всех реплик, иначе это приведет к расхождению реплик

![image alt text](/images/crdt-master-degree/image_26.png)

Рисунок 24[30]

### LogootSplit

Авторы LogootSplit[31] предлагают оперировать не символами, а строками. Logoot и TreeDoc похожи тем, что идентификаторы - это упорядоченные множества символов. В TreeDoc путь к узлу состоит из 0 и 1, а Logoot из набора цифр от 0 до 9. LogootSplit предлагает использовать для идентификаторов символы от ‘a’ до ‘z’. Для того, чтобы пользователи генерировали уникальные идентификаторы в начало каждого идентификатора записывается один из символов - идентификатор реплики. 

В модели LogootSplit идентификатор символа имеет вид base:offset, где base - представляет первый элемент, offset - последний элемент. ":" - оператор конкатенации.

Идентификатор строки имеет вид base[ (NOTE: EQUATION)] и представляет все символы идентификатора base: base: (NOTE: EQUATION), base:  (NOTE: EQUATION), ..., base: (NOTE: EQUATION). Символ (m+1) строки имеет вид base:( (NOTE: EQUATION)).

Например строка "HEY" в Logoot выглядит так <daa,H><dab,E><dac,Y>, если использовать символьные идентификаторы.  В модели LogootSplit та же самая строка будет выглядеть как один элемент: <da[a.c], HEY>. Модель позволяет вставлять еще строки в конец “HEY” не создавая дополнительных идентификаторов - <da[a.e], HEYWO>  например. Для того, чтобы несколько пользователей не могли генерировать одинаковые идентификаторы, используется условие, что только пользователь, создавший данный идентификатор может редактировать его. Ограничение происходит из практики: чаще всего тот пользователь, который создал предложение и редактирует его.

Документ редактируется используя локальные функции:

* insert(pos, str) - вставляет строку str на позицию pos

* remove(from, to) удаляет часть текста между позициями from, to включительно.

Для вставки обычно требуется создать новый идентификатор между двумя другими идентификаторами, другими словами вставить слово между двумя другими словами. Можно всегда найти такое слово, если предположить что слово не заканчивается на пустой символ ‘ ‘. Это легко в простых случаях, например есть два идентификатора ‘abc’  и ‘def’. Любое слово, которое начинается на ‘b’ или ‘c’ подойдет. В некоторых сложных случаях использует пустой символ ‘ ’. Можно легко добавить слово ‘aa’ между ‘a’ и ‘b’. Однако элемент, вставленный между ‘a’ и ‘aa’, будет идентифицирован как ‘a a’. Это позволяет иметь плотный набор идентификаторов. Как только новый идентификатор сгенерирован, вместе с операцией он отсылается на другие реплики. Вставка в уже сжатый идентификатор приведет к трем элементам: сжатый разделится на два идентификатора, похожих на вставляемый но соответствующий разделяемым идентификатором, и третьим идентификатором, лежащим между первых двух.

Чтобы удалить строку из документа необходимо найти ее идентификатор, который лежит между удаляемыми позициями для того чтобы отправить идентификатор на другие реплики и удалить из локального документа. Удаление также может привести к разделению идентификаторов. Например. Если из предыдущего примера мы удалим символ ‘Y’, то нужно удалить удалить идентификатор ‘dac’. После удаления документ будет выглядеть так - <da[a.b],HE><da[d.e],WO>

Функции insert/delete генерируют операции, которые будут разосланы другим репликам:

* add(id, str) добавляет строку str с идентификатором id документ

* del(id) удаляет интервал из строки с идентификатором id

Чтобы добавить новый идентификатор в документ сначала нужно найти его позицию среди других идентификаторов. Это делается с помощью двоичного поиска. Такая же операция проделывается, когда нужно удалить идентификатор.

Поиск всегда найдет такие идентификаторы, даже если на другой реплики пользователь применил локальные операции так как идентификаторы - уникальные.

Удаленные идентификаторы нельзя переиспользовать. Для того, чтобы избежать дублирования идентификаторов документ хранит информацию о base идентификаторе - максимальное и минимальное используемое значение. Также как Logoot, TreeDoc подход LogootSplit не требует от операций каузальности так как, идентификаторы уникальные.

В статье представлены три реализации внутренней структуры документа:

* LogootSplitNaive	 хранит все идентификаторы в списке	 	 	

* LogootSplitString хранит два списка: список для строк, список для идентификаторов

* LogootSplitAVL хранит пары идентикаторы-строка в структуре похожей на Rope Strings[32], а для балансировки применяет подход из AVL дерева[33]

Плюсы

* Производительней Logoot(Рисунок 25)

* Работает со строками

* Оптимизирован на вставку справа 

* Уменьшено количество метаданных на символ

![image alt text](/images/crdt-master-degree/image_27.png)

Рисунок 25[31]

### WOOTO

Алгоритм WOOTO реализован в Wiki - системе редактирования документов, представленной в [34]. 

#### Модель

Каждая реплика имеет свой уникальный монотонно возрастающий идентификатор siteId. При создании новой wiki-страницы ей присваивается уникальный идентификатор pageId. Страница состоит из последовательности четверок <idl,content,degree,visibility>, где

* idl уникальный идентификатор строки документа. Представляет собой пару <siteId, logicalClock>. Каждая реплика поддерживает логические часы. Идентификаторы строки получаются полностью упорядоченными.

* content - строка

* degree фиксированное число, которое генерируется при создании строки.

* visibility - флаг, обозначающий видимость строки

На рисунке 26 изображена страница, а на рисунке структура документа.

![image alt text](/images/crdt-master-degree/image_28.png)

![image alt text](/images/crdt-master-degree/image_29.png)

Рисунок 26[34]

Пустой документ состоит из двух виртуальных узлов. Вставка неконкурирующих строк осуществляется между узлами. Если между узлами уже есть строки, то есть вставка конкурирующая то выбирается местоположение с наименьшим значением degree. degree считается следующим образом:

degree = max(degree(lineA), degree(lineB)) + 1. Начальный значения degree для виртуальных узлов - 0.

### WOOTH

Алгоритм WOOTH[35] является наследником WOOTO и RGA. Документ в WOOTH использует хеш-таблицу и связный список по аналогии с RGA.

На рисунке 27 показан худший сценарий по времени, где R - количество реплик, H - количество операций.

![image alt text](/images/crdt-master-degree/image_30.png) 

Рисунок 27[35]

Время работы в среднем - рисунок 28.

![image alt text](/images/crdt-master-degree/image_31.png)

Рисунок 28[35]

с - средние количество конкурентных операций

n - размер документа(без удаленных символов)

N - общее количество вставляемых документов(включая удаленные)

k - средний размер идентификатора в Logoot

t=N-n количество удаленных символов

d=(t+c)/n среднее количество элементов(с удаленными и конкурентными)

### LSEQ

В модели LSEQ[36] документ представлен как множество  (NOTE: EQUATION), где elt или символ или строка, а id - неизменяемый идентификатор из множества идентификаторов  (NOTE: EQUATION). На множестве  (NOTE: EQUATION)определено отношение полного, порядка, все идентификаторы строго упорядочены. На документе D определены операции:

*  (NOTE: EQUATION)

*  (NOTE: EQUATION)

Идентификатор переменной длины id это последовательность цифр  (NOTE: EQUATION)

Каждый идентификатор представляет путь в дереве от корня к листу. На рисунке 29 идентификатор [10,13] обозначает путь к символу ‘b’. Предположим, что пользователь хочет вставить символ ‘z’ между ‘q’ и ‘p’.

* если p=[11], q=[14] то место для вставки есть - идентификаторы 12,13 обаа подходят.

* если p=[14],q=[15] то места для вставки на текущем уровне дерева нет. С помощью функции alloc создадим новый уровень в дереве, а затем выбираем идентификатор между возможными [14.00] и [14,99].

![image alt text](/images/crdt-master-degree/image_32.png) 

Рисунок 29[36]

В статье предлагается несколько стратегий создания идентификаторов:

* boundary+ strategy (B)

* a base doubling (D)						

* Round-Robin strategy choice (RR)						

* random strategy choice with base doubling (LSEQ)

### RGATreeSplit and LogootTree

Основная идея подхода в [37] это создать структуру данных с идентификаторами, которая будет находится локально на каждой реплике. Такую структуру можно легко добавить в уже существующие CRDT алгоритмы, тем самым ускорив доступ к узлам с символами. Авторы заметили, что каждый из CRDT содержит уникальные идентикаторы и построили отображение их на свои идентификаторы - idNode. Этой структурой может быть SkipList[38] для полностью упорядоченных идентификаторов в Logoot, TreeDoc, или деревом с весами для других CRDT структур.

Дерево с весами содержит набор узлов idNode, один из которых является корнем. Узел содержит ссылку на левый и правый дочерние узлы и ссылку на родительский узел. Также каждый узел хранит вес - размер поддерева. Такая структура позволяет быстро передивгаться по узлам CRDT документа, независимо от того, что за тип CRDT. 

Также авторы усовершенствовали алгоритм RGA добавив поддержку блочных идентификаторов как в LogootSplit. 

Плюсы

* Поиск узла за  (NOTE: EQUATION), где n - количество видимых элементов

* Легко добавляется к другим CRDT

* RGASplitTree в экспериментах показал наилучшие результаты

Минусы

* Дополнительная память на поддержку дерева идентификаторов

### Swarm RON

Swarm RON[39] - протокол с открытым исходным кодом, представляющий CRDT структуры данных для приложений.

### Модель

Протокол состоит из 5 ключевых компонент:

1. UUID - глобально уникальный 128-битный идентификатор. Состоит из из двух 60 битных частей: значения(value) и источника(origin). 4+4 бита зарезервировано под флаги. Существует 4 типа UUID:

* таймстамп события, который может быть либо логическим таймстампом или гибридным. Например: 1TUAQ+gritzko, где значение это монотонно возрастающий счетчик 1TUAQ в формате Base64, а источник - идентификатор реплики gritzko. Разделитель +.

* производный таймстамп. Такой же как таймстамп события, но ссылающийся на другой UUID. Например: 1TUAQ-gritzko. Разделитель -.

* имя. Либо глобальное, либо локальное к реплике. Например: foo, lww, bar - глобальные. MyVariable$gritzko - локальное. Разделитель $.

* хеш. Например 4Js8lam4LB%kj529smEsl, обе части - хеш суммы бит. Разделитель %.

2. Op. Операция - неизменяемая единица изменения данных. Операция - четверка значений UUID и ноль, либо больше значений атомов(atom). 

Значения UUID

* UUID типа данных, например lww, last-write-wins объект

* UUID объекта, 1TUAQ+gritzko

* UUID события 1TUAQ+gritzko

* UUID места, UUID ссылки. Например ‘bar’

Типы атомов

* строки

* целые числа

* числа с плавающей точкой

* ссылка на другой UUID 

Термы операций

* сырые операции(единичная операция, еще не обработанная редьюсером)

* операции после редьюсинга(операции во фрейме, обработанные редьюсером)

* заголовки фрейма, установленные редьюсером

* запросы

3. Фрейм - упорядоченный список операций

* состояние объекта - фрейм

* патч(дельта) - фрейм

* в основном все данные представляются, как частично упорядоченный лог фреймов

4. Редьюсер представляет тип данных в RON. Редьюсеры определяют как изменяется состояние объекта.

* редьюсер это чистая функция: f(state_frame, change_frame) -> new_state_frame, где фреймы либо пустые, либо единичные операции, либо результат предыдущего редьюсинга.

* редьюсеры обладают следующими целями

* ассоциативность. f(f(state, op1), op2) == f(state, patch) где patch == f(op1, op2)

* коммутативность для конкурентных операций(терпимы к каузальным частичным порядкам)

* идемпотентные. f(state, op1) == f(f(state, op1), op1) == f(state, f(op1, op1)))

* опционально, редьюсеры могут иметь более строгие гарантии, например полная коммутативность(терпима к применению каузальных объектов в "неправильном порядке")

* фрейм может быть одной операцией, патчем или полным состоянием. Редьюсер может переключаться в разные режимы:

* f(state, op) основанный на операциях

* f(state1, state2) основанный на состояниях

* f(state, patch) основанный на патчах(дельтах) 	

5. Маппер транслирует реплицированное состояние объекта из фрейма в другие форматы:

* мапперы превращают RON объекты в разные форматы

* мапперы однонаправленные: метаданные RON теряются при конвертации

* мапперы можно объединять в последовательность мапперов. Например: RON->JSON->HTML

#### Протокол

1. Атомы

* числа

* числа с плавающей точкой: 3.1415, 1.0е+6

* UTF-8 JSON экранированная строка, строка\n线\t\u7ebf\n라인

* RON UUID 1D4ICC-XU5eRJ, 1TUAQ+gritzko

 2. UUID использует сжатое представление

* RON UUID использует формат Base64 для компактного хранения. 

* UUID таймстампы могут различаться в точности, так же как и числа с плавающей точкой. Поэтому конечные нули отбрасываются.

* UUID упорядоченные

3. Сериализованные операции используют символы пунктуации, например 

*lww #1D4ICC-XU5eRJ @1D4ICC2-XU5eRJ :keyA 'valueA'

* * тип данных UUID

* # объект UUID

* @ 

* : местоположение UUID

* = число

* ‘ начало и конец строки

* ^ начало числа с плавающей точкой

* > начало UUID

* ! заканчивает заголовок фрейма(фрейм после редьюса имеет одну операцию заголовка) 

* ? заканчивает заголовок запроса(подписка на объект)

* . заканчивает фрейм

4. Фрейм  использует колоночное сжатие

* повторяющиеся UUID пропускаются

* RON использует префиксное сжатие для UUID, 1D4ICCE+XU5eRJ сжимается до {E если предшествовал 1DICC+XU5eRJ (символы `([{}])` отвечает за 4,5,...9 префикса)

* по умолчанию, UUID сжимается с предыдущими  UUID с таким же значением(идентификатор события с предыдущим идентификатором)

* символ ` меняет значение по умолчанию на значение UUID из предыдущей операции(Например идентификатор события и идентификатор объекта)

Рассмотрим JSON объект:

{"keyA":”valueA”, “keyB”:”valueB”}

Для данного объекта фрейм будет иметь три операции: одна операция на заголовок и две операции для пар ключ-значения:

type object         event           location value
-----------------------------------------------------
*lww #1D4ICC+XU5eRJ @1D4ICCE+XU5eRJ :0       !
*lww #1D4ICC+XU5eRJ @1D4ICCE+XU5eRJ :keyA    'valueA'
*lww #1D4ICC+XU5eRJ @1D4ICC1+XU5eRJ :keyB    'valueB'

В данном представлении повторяющие биты можно пропустить используя префиксное сжатие. Сжатое представление немного больше по объему, чем JSON. 

*lww#1D4ICC+XU5eRJ@`{E! :keyA'valueA' @{1:keyB'valueB'

Фрейм состоит из 12 UUID’ов (6 различных, 3 различных таймстампа) а также данные. Сжатый фрейм занимает меньше места чем два UUID из RFC4122. Если добавить идентификатор к объекту в JSON, то размер будет еще больше.

{"_id": "0651a600-2b49-11e6-8000-1696d3000000", "keyA":"valueA",
"keyB":"valueB"}

#### Бинарный протокол

Бинарный протокол эффективнее, чем текстовый из-за плотности битов, а также безопасно переводится во фрейм, так как для каждого поля указана длина поля.

Как и Base64, бинарный формат оптимизирован только для итерации по нему. Из-за сжатия длина записи получается различной длины. Сжатие зависит от итерации, так как есть операция - "взять предыдущее значение UUID".

Бинарный протокол стартует с зарезервированных битов RON и дескриптора фрейма, который описывает версию протокола и длину фрейма. Остальные данные - последовательность полей. Каждое поле начинается с дескриптора, описывающего тип поля и его длину.

Дескрипторы

Первые байты дескриптора описывают тип поля, остальные 4 описывают длину(Рисунок 30).

![image alt text](/images/crdt-master-degree/image_33.png)

Рисунок 30[39]

 Дескрипторы, описывающие тип поля, кодируют версию протокола(2 бита на мажорную версию, два бита на минорную. Например - 10 00 версия 2.0)

1. 00 операция

* 0000 сырая операция

* 0001 операция после редьюсинга

* 0010 заголовок операции

* 0011 запрос 

2. 01 UUID, несжатое

* 0100 тип

* 0101 идентификатор объекта

* 0110 идентификатор события

* 0111 идентификатор ссылка/местоположения

3. 10 UUID сжатый

* 1000 значение UUID, сжатое

* 1001 идентификатор объекта

* 1010 идентификатор события

* 1011 идентификатор ссылка/местоположения

4. 11 Атом

* 1100 UUID значение, несжатое

* 1101 целое число 

* 1110 строки

* 1111 число

Первые 4 бита кодируют длину фрейма, поля и запрос операции. Длина поля не включает в себя длину дескриптора, однако указанная длина меньше чем реальная длина хотя бы на 1 байт. Длины фрейма состоит из длины операций, длина операции состоит из длины полей, но значения длин могут не совпадать.

Если длина поля или фрейма меньше 7 байт, тогда значения кодируются напрямую в эти 4 бита с первым битом установленным в 0. Если первый бит 1, то следующие 3 бита кодируют длину следующего поля(от 1 до 7 байт).

Рассмотрим например кодировку для фрейма *now?

* 3 байта зарезервированы для RON, 0101 0010 0100 1111 0100 1110

* дескриптор фрейма: 1 байт(реальная длина 5, 1000 0101)

* дескриптор операции: 1 байт(реальная длина 4, 0011 0100)

* дескпритор UUID в несжатов виде: 1 байт(реальная длина 3, 0100 0011)

* now RON UUID: 3 байта(0000 1100 1011 0011 1110 1100, в несжатом виде содержит много нулей) 

Поскольку длина UUID меньше чем 16 байт, то для UUID не кодируется его длина. Дескриптор UUID’a всегда длиной 1 байт. Биты для длины суммируются с другими битами для длины, всего вместе 16 байт

Длина поля 0000 означают длину поля по-умолчанию:

* для целых чисел и чисел с плавающей точкой длина 0 означает =0 для целых чисел, ^0.0 на чисел с плавающей точкой

* для строк значение по-умолчанию - пустая строка

* для фреймов длина 0 означает пустой фрейм(проверка активности, keep alive)

* для сжатых UUID означает "нулевой" UUID (UUID у которого все поля 0)

* для операций означает операцию без полей

* для несжатых UUID, значение по умолчанию означает полный 128 битный UUID

Длина поля равная 1000 это зарезервированная константа, которая определяет дополнительную информацию для каждого типа.

* для UUID означает длину поля 8

* для операций означает, что "длина не указана"

* для фреймов также означает "длина не указана"(так как для если использовать в виде транспорта протокол WebSocket, то длину можно не указывать)

* для атомов значение зарезервировано

Несжатые UUID

UUID не сжимаются  относительно предшествующих UUID, хотя нулевые байты пропускаются. Парсинг тем не менее не ломается из-за того, что мы знаем длину каждого поля.

Первые 8 байт UUID’а, байты источник устанавливаются в нули, и последующие "незанятые“ байты устанавливаются в нули. Часто используемые трансцендентные UUID(lww, rga, db, now), которые обозначают тип объекта, например. 

UUID lww обозначает тип объект - last-write-wins. С "незанятыми" байтами lww будет иметь вид “0lww0000000 00000000000”

### Causal Tree

Cauual Tree[41] лежат в основе внутренней структуры rga в протоколе RON. Это обеспечивает скорость на вставку  (NOTE: EQUATION)

### Анализ 

Для практического применения данных алгоритмов не решена проблема эффективного хранения внутренних структур данных в персистентном хранилище.

Swarm решает эту проблему предоставляя протокол, который поддерживает компактное представление, передаваемых по сети данных и хранение лога операций в базе данных типа ключ-значение. 

База данных типа ключ-значение - базовый примитив баз данных, и легко осуществляется моделирование хранения поверх любой базы данных.

#### Компактное представление операций

Во всех основанных на CRDT алгоритмах полный порядок между коммутативными операциями выстраивается с помощью уникальных идентификаторов.

* WOOT уникальная пара соседних узлов и упорядочения символов в конкурирующих операциях

* TreeDoc  уникальный путь в дереве документа

* Logoot - уникальные позиционные идентификаторы

* RGA уникальные s4vector 

Swarm использует в качестве идентификатора Swarm UUID.

Рассмотрим пример с редактированием текста. Каждый символ имеет свой UUID. Если применить такой подход к JSON, то размер JSON получится гораздо большим, чем с при использовании RON. 

Фраза "Hello world" написанная двумя пользователями bart и lisa 27 ноября 2017 года в 9 вечера. Сжатый RGA(Replicated Growable Array) фрейм будет выглядеть так:

*rga#1UQ8p+bart@1UQ8yk+lisa!
    @(s+bart'H'@[r'e'@(t'l'@[T'l'@[i'o'
    @(w+lisa' '@(x'w'@(y'o'@[1'r'@{a'l'@[2'd'@[k'!'

Если отформатировать сжатый фрейм, то результат будет человеко-читаемым.

*rga #1UQ8p+bart @1UQ8yk+lisa     !
                 @(s+bart        'H'
                 @[r             'e'
                 @(t             'l'
                 @[T             'l'
                 @[i             'o'
                 @(w+lisa        ' '
                 @(x             'w'
                 @(y             'o'
                 @[1             'r'
                 @{a             'l'
                 @[2             'd'
                 @[k             '!'

Полностью несжатым фрейм занимает больше места:

*rga   #1UQ8p+bart   @1UQ8yk+lisa     :0      !
*rga   #1UQ8p+bart   @1UQ8s+bart      :0     'H'
*rga   #1UQ8p+bart   @1UQ8sr+bart     :0     'e'
*rga   #1UQ8p+bart   @1UQ8t+bart      :0     'l'
*rga   #1UQ8p+bart   @1UQ8tT+bart     :0     'l'
*rga   #1UQ8p+bart   @1UQ8ti+bart     :0     'o'
*rga   #1UQ8p+bart   @1UQ8w+lisa      :0     ' '
*rga   #1UQ8p+bart   @1UQ8x+lisa      :0     'w'
*rga   #1UQ8p+bart   @1UQ8y+lisa      :0     'o'
*rga   #1UQ8p+bart   @1UQ8y1+lisa     :0     'r'
*rga   #1UQ8p+bart   @1UQ8y1a+lisa    :0     'l'
*rga   #1UQ8p+bart   @1UQ8y2+lisa     :0     'd'
*rga   #1UQ8p+bart   @1UQ8yk+lisa     :0     '!'

Маппер типа txt конвертирует данный фрейм в в текст:

*txt #1UQ8p+bart @1UQ8yk+lisa 'Hello world!'

#### Хранение лога операций

В OT алгоритмах часто используется лог для хранения операций. Лог - удобная структура для хранения в базе данных. В CRDT алгоритмах WOOT, Logoot, TreeDoc используются свои структуры данных, заточенный на на скорость вставки, удаления, а не удобство хранения. Swarm использует упорядоченный лог операций, который подходит для любой базы данных.

#### Открытый исходный код

У всех OT алгоритмов есть одна общая проблема, они разработаны для закрытого программного обеспечения и корректная реализация алгоритма займет достаточно времени. Существует несколько библиотек с открытым исходным кодом, которые реализуют OT алгоритмы, например ShareDB[40], которые можно использовать в продуктах для совместного редактирования текста. 

Таблица 1 Анализ OT алгоритмов

<table>
  <tr>
    <td></td>
    <td>Плюсы</td>
    <td>Минусы</td>
  </tr>
  <tr>
    <td>dOPT(1989)</td>
    <td>Представлена модель консистентности и свойства</td>
    <td>Функция трансформации определена только для операций Insert, Delete. Хотя сам алгоритм dOPT синхронизирует любые операции
Не решена проблема двух и более конкурирующих зависимых операций.
Бесконечно растущий лог запросов и матрица трансформаций	
dOPT puzzle</td>
  </tr>
  <tr>
    <td>Jupiter(1995)</td>
    <td>Решение конфликтов перенесено на сервер
На сервере хранится матрица всех состояний, что позволяет не ждать "опаздывающую" операцию и применять следующие.
Решен dOPT puzzle</td>
    <td>
Растущая матрица состояний
</td>
  </tr>
  <tr>
    <td>Adopted(1996)</td>
    <td>Решен dOPT puzzle</td>
    <td>Хранение матрицы переходов состояний размера n, где n - количество реплик. При большой истории изменений может потребоваться больше памяти, чем при хранении лога операций.
Возможны ситуации, что если операции с других реплик приходят с задержкой, то “накапливается” количество трансформаций, которые нужно произвести.</td>
  </tr>
  <tr>
    <td>GOT(1997,1998)</td>
    <td>Представлено свойство намерения
Операции работают не с символами, а со строками.
Впервые представлена очистка устаревших операций и возможность отмены/применения отмененных операций(undo/do/redo)
Решен dOPT puzzle

</td>
    <td>В алгоритме также используется лог операций.. 
Следует отметить, что отмена/применение отмененных операций нельзя производить из пользовательского интерфейса, это внутренние операции.</td>
  </tr>
  <tr>
    <td>GOTO(1998)</td>
    <td>Меньшее количество операций трансформаций</td>
    <td></td>
  </tr>
  <tr>
    <td>SOCK2(1997)</td>
    <td>Новая модель трансформаций
История объекта выстраивается инкрементально</td>
    <td></td>
  </tr>
  <tr>
    <td>SOCK3/4(1998)</td>
    <td>Если секвенсор выходит из строя локальные операции продолжают применяться. После того как секвенсор восстановится - редактирование можно продолжить
SOCK4:Старые операции не нужны для трансформаций</td>
    <td>SOCK3: трансформации из “прошлого” необходимы для последующих трансформаций
Доказательство корректности алгоритма нетривиально
Для SOCK4 желательно быстрое сетевое соединение для секвенсора</td>
  </tr>
  <tr>
    <td>CoWord(2004)</td>
    <td>Работает с реальным редактором</td>
    <td>Программа должна предоставлять интерфейс для возможно подключения OT алгоритма
Все объекты программы должны быть адаптированы для трансформаций. Для каждого нового объекта, который нужно синхронизировать определяется новый набор функций трансформации.</td>
  </tr>
  <tr>
    <td>TreeOPT(2002,2003)</td>
    <td>Работает со строками
Поддерживает XML 
Происходит меньше трансформаций из-за многоуровневости буфера</td>
    <td></td>
  </tr>
  <tr>
    <td>MOT1/2(2006)</td>
    <td>Используют отдельный синхронизатор операций. На реплики операции отправляются уже в правильном порядке.</td>
    <td></td>
  </tr>
  <tr>
    <td>COT(2006)</td>
    <td>Представлена новая модель основанная на контекстах операций.</td>
    <td></td>
  </tr>
  <tr>
    <td>TIBOT(2004)</td>
    <td>Решается dOPT пазл, используя одномерный исторический буфер
Алгоритмическая сложность алгоритма O(n) в сравнении с O(n2)в GOTO алгоритме
Решается TP2 puzzle без использования ET трансформаций и секвенсора</td>
    <td></td>
  </tr>
  <tr>
    <td>SDT(2004)</td>
    <td>Новая модель консистентности CSM основанная на эффектах операций
Решают ERV puzzle
Формально доказано решения TP2 puzzle</td>
    <td></td>
  </tr>
  <tr>
    <td>LDT(2005)</td>
    <td>Улучшают алгоритм SDT по алгоритмической сложности функции интеграции удаленных операции с O(n3)до O(n2) в худшем случае, дают более просто условия на функции трансформации.</td>
    <td></td>
  </tr>
  <tr>
    <td>Google Doc(Wave)</td>
    <td>Wave умеет композировать операции - сливать несколько операций в одну. 
Wave сервер работает по модели Jupiter - все операции отправляются на сервер, а затем каузально синхронизированные и трансформированные отправляются на реплики.</td>
    <td>Композиция операций применяется только к некоторым операциям, и является некоммутативной - важен порядок сливания операции.
Возрастает нагрузка на сервер</td>
  </tr>
</table>


Таблица 2. Анализ CRDT структур данных

<table>
  <tr>
    <td></td>
    <td>Плюсы</td>
    <td>Минусы</td>
  </tr>
  <tr>
    <td>WOOTO</td>
    <td>Прост в реализации</td>
    <td>Не удаляет символы из графа
Документ растет бесконечно</td>
  </tr>
  <tr>
    <td>TreeDoc</td>
    <td>Компактные идентификаторы, но растут бесконечно.
Вместо атомов можно использовать любый неизменяемые структуры</td>
    <td>Дерево получается несбалансированным из-за вставки текста справа.
Необходим сборщик мусора</td>
  </tr>
  <tr>
    <td>Logoot</td>
    <td>Работает со строками
Неограниченное количество пользователей
Без меток сокрытия(tombstone)
Переиспользуемые идентификаторы после удаления</td>
    <td>Идентификаторы неограниченной длины</td>
  </tr>
  <tr>
    <td>RGA</td>
    <td>Идентификаторы фиксированной длины.
O(1)сложность на вставку, в отличие от O(n2)в OT алгоритмах</td>
    <td>Удаленные узлы не удаляются, а помечаются как удаленные
Алгоритм сборки удаленных узлов должен синхронно убирать узлы сразу со всех реплик, иначе это приведет к расхождению реплик</td>
  </tr>
  <tr>
    <td>LogootSplit</td>
    <td>Производительней Logoot
Работает со строками
Оптимизирован на вставку справа 
Уменьшено количество метаданных на символ</td>
    <td></td>
  </tr>
  <tr>
    <td>LogootTree/RgaSplitTree</td>
    <td>Поиск узла за O(log(n)), где n - количество видимых элементов. Легко добавляется к другим CRDT. RGASplitTree в экспериментах показал наилучшие результаты</td>
    <td>Дополнительная память на поддержку дерева идентификаторов</td>
  </tr>
  <tr>
    <td>Swarm Causal Tree</td>
    <td>Компактное представление операций.
Фиксированный размер идентификаторов. Поддержка склейки операций в состояние.</td>
    <td>Требуется время на разжатие фреймов</td>
  </tr>
</table>


Таблица 3. Размер идентификатора

<table>
  <tr>
    <td>WOOTO</td>
    <td>8 байт replicaId, 4 байта - logical clocks, 4 байта - degree, visibility - 1 байт
</td>
  </tr>
  <tr>
    <td>TreeDoc</td>
    <td>8 байт replicaId, 4 байта counter, идентификатор символа неограничен
</td>
  </tr>
  <tr>
    <td>Logoot</td>
    <td>8 байт replicaId + position, 4 байта - logical clocks, идентификатор позиции 20 байт</td>
  </tr>
  <tr>
    <td>RGA</td>
    <td>s4vector + 3*указателя, где s4vector = 4 байта ssn, 4 байта sid, 4 байта sum, 1 байт</td>
  </tr>
  <tr>
    <td>LogootSplit</td>
    <td>8 байт replicaId + position, 4 байта - logical clocks, идентификатор позиции ~ 20 байт, offset - 4 байт
</td>
  </tr>
  <tr>
    <td>LogootTree</td>
    <td>8 байт replicaId + position, 4 байта - logical clocks, идентификатор позиции ~ 20 байт, offset - 4 байт, + 3 указателя * высота дерева</td>
  </tr>
  <tr>
    <td>RgaSplitTree</td>
    <td>2 s4vector + 3*указателя + offset(4 байта)</td>
  </tr>
  <tr>
    <td>Swarm Causal Tree</td>
    <td>4 * 4 Swarm UUID = 4 * 8 байт</td>
  </tr>
</table>


Таблица 4. Сравнение размера метаданных

<table>
  <tr>
    <td></td>
    <td>Размер идентификатора на один символ</td>
    <td>Оценка для наихудшего случая</td>
  </tr>
  <tr>
    <td>WOOTO</td>
    <td>17 байт</td>
    <td>O(N)</td>
  </tr>
  <tr>
    <td>TreeDoc</td>
    <td>> 12 байт </td>
    <td>O(N)</td>
  </tr>
  <tr>
    <td>Logoot</td>
    <td> > 12 байт</td>
    <td>O(kn)</td>
  </tr>
  <tr>
    <td>RGA</td>
    <td>26 + 12 = 38 байт</td>
    <td>O(N)</td>
  </tr>
  <tr>
    <td>LogootSplit</td>
    <td>> 16 байт на блок</td>
    <td>O(kn)</td>
  </tr>
  <tr>
    <td>LogootTree</td>
    <td>> 16 + 12 байт на блок</td>
    <td>O(N2)</td>
  </tr>
  <tr>
    <td>RgaSplitTree</td>
    <td> > 38 + 12 байт</td>
    <td>O(N)</td>
  </tr>
  <tr>
    <td>Swarm Causal Tree</td>
    <td>32 байта</td>
    <td>O(N)</td>
  </tr>
</table>


Таблица 5. Сравнительный анализ времени работы операций CRDT структур и некоторых OT алгоритмов для среднего случая

<table>
  <tr>
    <td></td>
    <td>WOOT</td>
    <td>WOOTO</td>
    <td>WOOTH</td>
    <td>TreeDoc</td>
    <td>Logoot</td>
    <td>RGA</td>
    <td>LogootSplit</td>
    <td>RgaSplit Tree</td>
    <td>Swarm Causal Tree</td>
    <td>OT
SOCK2/GOT</td>
  </tr>
  <tr>
    <td>локальная вставка</td>
    <td>O(Nd2)</td>
    <td>O(Nd2)</td>
    <td>O(N+d2)</td>
    <td>sk</td>
    <td>O(k)</td>
    <td>O(N)</td>
    <td>O(log(n)))</td>
    <td>O(log(n))</td>
    <td>O(nlog(n))</td>
    <td>O(1)</td>
  </tr>
  <tr>
    <td>локальное удаление</td>
    <td>O(N)</td>
    <td>O(N)</td>
    <td>O(N)</td>
    <td>sk</td>
    <td>O(1)</td>
    <td>O(N)</td>
    <td>O(log(n))</td>
    <td>O(log(n))</td>
    <td>O(nlog(n))</td>
    <td>O(1)</td>
  </tr>
  <tr>
    <td>удаленная вставка</td>
    <td>O(Nd2)</td>
    <td>O(N+d2)
</td>
    <td>O(d2)</td>
    <td>sk</td>
    <td>O(klog(n))</td>
    <td>O(1+c/n)
</td>
    <td>O(log(n))</td>
    <td>O(log(n))</td>
    <td>O(nlog(n))</td>
    <td>O(n2)
</td>
  </tr>
  <tr>
    <td>удаленное удаление</td>
    <td>O(N)</td>
    <td>O(N)</td>
    <td>O(1)</td>
    <td>sk</td>
    <td>O(klog(n))</td>
    <td>O(1)</td>
    <td>O(log(n))</td>
    <td>O(log(n))</td>
    <td>O(nlog(n))</td>
    <td>O(n2)</td>
  </tr>
</table>


 (NOTE: EQUATION) средние количество конкурентных операций

 (NOTE: EQUATION) размер документа без удаленных символов

 (NOTE: EQUATION) общее количество вставляемых символов, включая удаленные

 (NOTE: EQUATION)размер вставляемой строки/символа

 (NOTE: EQUATION)средний размер идентификатора в Logoot

 (NOTE: EQUATION) количество удаленных символов

 (NOTE: EQUATION) среднее количество элементов с удаленными и конкурентными

Таблица 6. Рекомендации по области применения разных алгоритмов

<table>
  <tr>
    <td>OT</td>
    <td>Некоторые алгоритмы (GOT, Jupiter) позволяют производить  трансформации на сервере и подходят для редактирования документов не требующих строгой корректности на маломощных устройствах. </td>
  </tr>
  <tr>
    <td>WOOT, TreeDoc, Logoot</td>
    <td>Подходят для документов небольших размеров и небольшого количества пользователей. </td>
  </tr>
  <tr>
    <td>RgaSplitTree, LogootTree, LogootSplit</td>
    <td>Идентификаторы символов имеют конечную или предсказуемую длину. Подходит для больших документов с ограниченным количеством пользователей.</td>
  </tr>
  <tr>
    <td>Swarm RON</td>
    <td>Документы любого размера и неограниченное количество пользователей. Периодическое сжатие операций решает проблему бесконечного роста документа.</td>
  </tr>
</table>


Выводы

* CRDT алгоритмы намного опережают по скорости применения операций OT алгоритмы. И также проще в доказательстве корректности.

* Количество метаданных зависит от размера идентификатора и структуры данных внутри документа. Один из перспективных подходов - это сжатие идентификаторов и упаковка в один идентификатор нескольких символов. 

## Реализация протокола RON

Swarm поддерживает архитектуру как сервер-клиент, так и peer-to-peer[44]. Для того чтобы использовать протокол на нескольких устройствах необходимо реализовать клиент протокола под устройство, на котором используется Swarm. Для браузера уже существует реализация протокола на языке Javascript[43]. Для поддержки редактирования текста с Android устройств была разработана Java версия протокола RON[42].

# Заключение

В работе был произведен анализ систем группового редактирования текста, проведено сравнение алгоритмов OT и CRDT по таким параметрам, как скорость применения операций, количество метаданных. По результатам проведенного анализа сформулированы рекомендации по применению.

Написана реализация протокола Swarm на Java. Результаты сравнения приведены приведены в таблицах 1,2,3,4,5.

Планы на будущее. 

* Экспериментально показать, что в протоколе Swarm количество метаданных растет медленнее чем в RgaSplitTree, LogootSplit.

* Экспериментально показать, что в Swarm слияние происходит за O(n) в отличие от OT(n^2)

## Список используемых источников

[1] Concurrency Control in Groupware Systems, C.A. Ellis S.J. Gibbs, 1989

[2] High-Latency, Low-Bandwidth Windowing in the Jupiter Collaboration System, David A. Nichols, Pavel Curtis, Michael Dixon, and John Lumping, 1995

[3] An Integrating, Transformation-Oriented Approach to Concurrency Control and Undo in Group Editors, Matthias Ressel, Doris Nitsche-Ruhland, and Rul Gunzenha ̈user, 1996

[4] A Consistency Model and Supporting Schemes for Real-time Cooperative Editing Systems C. Sun Y. Yangz Y. Zhangy D. Chen

[5] A Generic Operation Transformation Scheme for Consistency Maintenance in Real-time Cooperative Editing Systems

[6] Achieving Convergence, Causality Preservation, and Intention Preservation in Real-Time Cooperative Editing Systems

[7] Reversible inclusion and exclusion transformation for string-wise operations in cooperative editing systems					

[8] Operational Transformation in Real Time Group Editors. Issues Algorithms and Achievements

[9] Serialization of Concurrent Operations in a Distributed Collaborative Environment

[10] Concurrent Operations in a Distributed and Mobile Collaborative Environment

[11] Copies convergence in a distributed real−time collaborative environment

[12] Tree-based model algorithm for maintaining consistency in real-time collaborative editing systems					

[13] Customizable collaborative editor relying on treeOPT algorithm

[14] An arbitration scheme for concurrency control in distributed groupware

[15]Leveraging Single-user Applications for Multi-user Collaboration: the CoWord Approach

[16] Using the Transformational Approach to Build a Safe and Generic Data Synchronizer

[17] Synchronizer Based on Operational Transformation for P2P Environments

[18] A Time Interval Based Consistency Control Algorithm for Interactive Groupware Applications

[19] Undo as Concurrent Inverse in Group Editors

[20] Operation Context and Context-based Operational Transformation

[21] Preserving Operation Effects Relation in Group Editors

[22]A Landmark-Based Transformation Approach to Concurrency Control in Group Editors

[23] [http://www.waveprotocol.org/protocol/draft-protocol-specs/draft-protocol-spec](http://www.waveprotocol.org/protocol/draft-protocol-specs/draft-protocol-spec)

[24]

[http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation](http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation)

[25] [https://people.apache.org/~al/wave_docs/ApacheWaveProtocol-0.4.pdf](https://people.apache.org/~al/wave_docs/ApacheWaveProtocol-0.4.pdf)

[26] Conflict-free Replicated Data Types	

[27] Data Consistency for P2P Collaborative Editing

[28] Designing a commutative replicated data type

[29] Logoot: A Scalable Optimistic Replication Algorithm for Collaborative Editing on P2P Networks

[30] Replicated abstract data types: Building blocks for collaborative applications

[31] Supporting Adaptable Granularity of Changes for Massive-scale Collaborative Editing	

[32] Ropes: an alternative to strings Hans-J. Boehm, Russ Atkinson, Michael Plass

[33] Г. М. Адельсон-Вельский, Е. М. Ландис, Один алгоритм организации информации, Докл. АН СССР, 1962, том 146, номер 2, 263–266

[34] Wooki: a P2P Wiki-based Collaborative Writing Tool

[35] Evaluating CRDTs for Real-time Document Editing

[36] LSEQ: an Adaptive Structure for Sequences in Distributed Collaborative Editing

[37] High Responsiveness for Group Editing CRDTs

[38] Skip Lists: A Probabilistic Alternative to Balanced Trees

[39] [https://github.com/gritzko/ron/blob/master/README.md](https://github.com/gritzko/ron/blob/master/README.md)

[40] [https://github.com/share/sharedb](https://github.com/share/sharedb)

[41] Deep Hypertext with Embedded Revision Control Implemented in Regular Expressions	

[42] [https://github.com/volyx/java-ron](https://github.com/volyx/java-ron)

[43] [https://github.com/gritzko/swarm](https://github.com/gritzko/swarm)

[44] [https://en.wikipedia.org/wiki/Peer-to-peer](https://en.wikipedia.org/wiki/Peer-to-peer)

	

			

